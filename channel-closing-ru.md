# Как корректно закрывать каналы

Несколько дней назад я написал статью, которая объясняет правила работы с каналами в Go. Эта статья получила много голосов на reddit и HN, но также были некоторые критические замечания по деталям дизайна каналов Go.

Я собрал некоторые критические замечания по следующим конструкциям и правилам каналов Go:

* нет простого и универсального способа проверить, закрыт ли канал, без изменения статуса канала.
* закрытие закрытого канала вызовет панику, поэтому опасно закрывать канал, если закрывающие не знают, закрыт ли канал.
* отправка значений в закрытый канал вызовет панику, поэтому опасно отправлять значения в канал, если отправители не знают, закрыт ли канал.

Критические замечания выглядят разумными, однако на самом деле это не так. Да, действительно нет встроенной функции для проверки, был ли закрыт канал.

Действительно есть простой метод проверить, закрыт ли канал, если вы можете гарантировать, что значения никогда не были (и не будут) отправлены в канал. Метод был показан в последней статье. Здесь, для лучшей связности, метод перечислен в следующем примере снова.

```go
package main

import "fmt"

type T int

func IsClosed(ch <-chan T) bool {
	select {
	case <-ch:
		return true
	default:
	}
	return false
}

func main() {
	c := make(chan T)
	fmt.Println(IsClosed(c)) // false
	close(c)
	fmt.Println(IsClosed(c)) // true
}
```

Как упоминалось выше, это не универсальный способ проверить, закрыт ли канал.

На самом деле, даже если есть простая встроенная функция `closed` для проверки, был ли закрыт канал, ее полезность будет очень ограниченной, так же как и встроенная функция `len` для проверки текущего количества значений, хранящихся в буфере значений канала. Причина в том, что статус проверенного канала может измениться сразу после возврата вызова таких функций, так что возвращенное значение уже не может отражать последний статус только что проверенного канала. Хотя это нормально прекратить отправку значений в канал `ch`, если вызов `closed(ch)` возвращает `true`, небезопасно закрывать канал или продолжать отправлять значения в канал, если вызов `closed(ch)` возвращает `false`.

## Принцип закрытия каналов

Один общий принцип использования каналов Go заключается в том, что не следует закрывать канал со стороны получателя и не следует закрывать канал, если у канала есть несколько конкурентных отправителей. Другими словами, мы должны закрывать канал только в горутине отправителя, если отправитель является единственным отправителем канала.

(Ниже мы будем называть вышеуказанный принцип принципом закрытия каналов.)

Конечно, это не универсальный принцип закрытия каналов. Универсальный принцип: не закрывать (или отправлять значения в) закрытые каналы. Если мы можем гарантировать, что никакие горутины больше не будут закрывать и отправлять значения в незакрытый ненулевой канал, то горутина может безопасно закрыть канал. Однако, создание таких гарантий получателем или одним из многих отправителей канала обычно требует больших усилий и часто усложняет код. Напротив, гораздо проще придерживаться принципа закрытия каналов, упомянутого выше.

## Решения, которые закрывают каналы грубо

Если вы все равно хотите закрыть канал со стороны получателя или в одном из нескольких отправителей канала, то вы можете использовать механизм `recover` для предотвращения возможной паники от краша вашей программы. Вот пример (предполагается, что тип элемента канала — `T`).

```go
func SafeClose(ch chan T) (justClosed bool) {
	defer func() {
		if recover() != nil {
			// Результат возврата может быть изменен
			// в вызове функции defer.
			justClosed = false
		}
	}()

	// предполагаем ch != nil здесь.
	close(ch)   // паника, если ch закрыт
	return true // <=> justClosed = true; return
}
```

Это решение явно нарушает принцип закрытия каналов.

Та же идея может использоваться для отправки значений в потенциально закрытый канал.

```go
func SafeSend(ch chan T, value T) (closed bool) {
	defer func() {
		if recover() != nil {
			closed = true
		}
	}()

	ch <- value  // паника, если ch закрыт
	return false // <=> closed = false; return
}
```

Грубое решение не только нарушает принцип закрытия каналов, но и могут возникать гонки данных в процессе.

## Решения, которые закрывают каналы вежливо

Многие люди предпочитают использовать `sync.Once` для закрытия каналов:

```go
type MyChannel struct {
	C    chan T
	once sync.Once
}

func NewMyChannel() *MyChannel {
	return &MyChannel{C: make(chan T)}
}

func (mc *MyChannel) SafeClose() {
	mc.once.Do(func() {
		close(mc.C)
	})
}
```

Конечно, мы также можем использовать `sync.Mutex` для избежания закрытия канала несколько раз:

```go
type MyChannel struct {
	C      chan T
	closed bool
	mutex  sync.Mutex
}

func NewMyChannel() *MyChannel {
	return &MyChannel{C: make(chan T)}
}

func (mc *MyChannel) SafeClose() {
	mc.mutex.Lock()
	defer mc.mutex.Unlock()
	if !mc.closed {
		close(mc.C)
		mc.closed = true
	}
}

func (mc *MyChannel) IsClosed() bool {
	mc.mutex.Lock()
	defer mc.mutex.Unlock()
	return mc.closed
}
```

Эти способы могут быть вежливыми, но они могут не избежать гонок данных. В настоящее время спецификация Go не гарантирует, что гонки данных не происходят, когда операция закрытия канала и операция отправки в канал выполняются конкурентно. Если функция `SafeClose` вызывается конкурентно с операцией отправки в канал на тот же канал, могут возникать гонки данных (хотя такие гонки данных обычно не причиняют никакого вреда).

## Решения, которые закрывают каналы корректно

Один недостаток вышеуказанной функции `SafeSend` заключается в том, что ее вызовы не могут использоваться как операции отправки, которые следуют за ключевым словом `case` в блоках `select`. Другой недостаток вышеуказанных функций `SafeSend` и `SafeClose` заключается в том, что многие люди, включая меня, считают, что вышеуказанные решения с использованием `panic/recover` и пакета `sync` не являются корректными. Ниже будут представлены некоторые решения на чистом канале без использования `panic/recover` и пакета `sync` для различных ситуаций.

(В следующих примерах используется `sync.WaitGroup` для завершенности примеров. Возможно, не всегда необходимо использовать его в реальной практике.)

### 1. M получателей, один отправитель, отправитель говорит "больше не отправлять" путем закрытия канала данных

Это самая простая ситуация, просто позвольте отправителю закрыть канал данных, когда он не хочет отправлять больше.

```go
package main

import (
	"time"
	"math/rand"
	"sync"
	"log"
)

func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20
	log.SetFlags(0)

	// ...
	const Max = 100000
	const NumReceivers = 100
	wgReceivers := sync.WaitGroup{}
	wgReceivers.Add(NumReceivers)

	// ...
	dataCh := make(chan int)

	// отправитель
	go func() {
		for {
			if value := rand.Intn(Max); value == 0 {
				// Единственный отправитель может закрыть
				// канал в любое время безопасно.
				close(dataCh)
				return
			} else {
				dataCh <- value
			}
		}
	}()

	// получатели
	for i := 0; i < NumReceivers; i++ {
		go func() {
			defer wgReceivers.Done()

			// Получать значения до тех пор, пока dataCh
			// не закрыт и очередь буфера значений
			// dataCh не станет пустой.
			for value := range dataCh {
				log.Println(value)
			}
		}()
	}

	wgReceivers.Wait()
}
```

### 2. Один получатель, N отправителей, единственный получатель говорит "пожалуйста, прекратите отправлять больше" путем закрытия дополнительного сигнального канала

Это ситуация немного более сложная, чем вышеуказанная. Мы не можем позволить получателю закрыть канал данных для остановки передачи данных, так как это нарушит принцип закрытия каналов. Но мы можем позволить получателю закрыть дополнительный сигнальный канал, чтобы уведомить отправителей прекратить отправку значений.

```go
package main

import (
	"time"
	"math/rand"
	"sync"
	"log"
)

func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20
	log.SetFlags(0)

	// ...
	const Max = 100000
	const NumSenders = 1000
	wgReceivers := sync.WaitGroup{}
	wgReceivers.Add(1)

	// ...
	dataCh := make(chan int)
	stopCh := make(chan struct{})
		// stopCh — это дополнительный сигнальный канал.
		// Его отправитель — это получатель канала
		// dataCh, а его получатели — это
		// отправители канала dataCh.

	// отправители
	for i := 0; i < NumSenders; i++ {
		go func() {
			for {
				// Операция try-receive предназначена для
				// попытки выйти из горутины как можно
				// раньше. Для этого конкретного примера
				// это не обязательно.

				select {
				case <- stopCh:
					return
				default:
				}

				// Даже если stopCh закрыт, первая ветка
				// во втором select может быть
				// все еще не выбрана для некоторых циклов, если
				// отправка в dataCh также не заблокирована.
				// Но это приемлемо для этого
				// примера, поэтому первый блок select
				// выше может быть опущен.

				select {
				case <- stopCh:
					return
				case dataCh <- rand.Intn(Max):
				}
			}
		}()
	}

	// получатель
	go func() {
		defer wgReceivers.Done()

		for value := range dataCh {
			if value == Max-1 {
				// Получатель канала dataCh также является
				// отправителем stopCh. Здесь безопасно
				// закрыть сигнальный канал.
				close(stopCh)
				return
			}

			log.Println(value)
		}
	}()

	// ...
	wgReceivers.Wait()
}
```

Как упоминается в комментариях, для дополнительного сигнального канала его отправителем является получатель канала данных. Дополнительный сигнальный канал закрывается его единственным отправителем, что соблюдает принцип закрытия каналов.

В этом примере канал `dataCh` никогда не закрывается. Да, каналы не обязательно закрывать. Канал будет в конечном итоге собран сборщиком мусора, если на него больше не ссылаются горутины, закрыт он или нет. Так что корректность закрытия канала здесь заключается не в закрытии канала.

### 3. M получателей, N отправителей, любой из них говорит "давайте закончим игру", уведомляя модератора закрыть дополнительный сигнальный канал

Это самая сложная ситуация. Мы не можем позволить ни одному из получателей и отправителей закрыть канал данных. И мы не можем позволить ни одному из получателей закрыть дополнительный сигнальный канал, чтобы уведомить всех отправителей и получателей выйти из игры. Любое из этих действий нарушит принцип закрытия каналов. Однако мы можем ввести роль модератора для закрытия дополнительного сигнального канала. Один трюк в следующем примере — как использовать операцию try-send для уведомления модератора закрыть дополнительный сигнальный канал.

```go
package main

import (
	"time"
	"math/rand"
	"sync"
	"log"
	"strconv"
)

func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20
	log.SetFlags(0)

	// ...
	const Max = 100000
	const NumReceivers = 10
	const NumSenders = 1000
	wgReceivers := sync.WaitGroup{}
	wgReceivers.Add(NumReceivers)

	// ...
	dataCh := make(chan int)
	stopCh := make(chan struct{})
		// stopCh — это дополнительный сигнальный канал.
		// Его отправитель — это горутина модератора, показанная
		// ниже, а его получатели — это все отправители
		// и получатели dataCh.

	toStop := make(chan string, 1)
		// Канал toStop используется для уведомления
		// модератора закрыть дополнительный сигнальный
		// канал (stopCh). Его отправители — это любые отправители
		// и получатели dataCh, а его получатель —
		// горутина модератора, показанная ниже.
		// Это должен быть буферизованный канал.

	var stoppedBy string

	// модератор
	go func() {
		stoppedBy = <-toStop
		close(stopCh)
	}()

	// отправители
	for i := 0; i < NumSenders; i++ {
		go func(id string) {
			for {
				value := rand.Intn(Max)
				if value == 0 {
					// Здесь операция try-send предназначена
					// для уведомления модератора закрыть
					// дополнительный сигнальный канал.

					select {
					case toStop <- "sender#" + id:
					default:
					}
					return
				}

				// Операция try-receive здесь предназначена для
				// попытки выйти из горутины отправителя как
				// можно раньше. Блоки try-receive и
				// try-send select специально
				// оптимизированы стандартным компилятором Go,
				// поэтому они очень эффективны.

				select {
				case <- stopCh:
					return
				default:
				}

				// Даже если stopCh закрыт, первая ветка
				// в этом блоке select может быть
				// все еще не выбрана для некоторых циклов
				// (и навсегда в теории), если отправка
				// в dataCh также не блокируется. Если
				// это неприемлемо, то вышеуказанная
				// операция try-receive обязательна.

				select {
				case <- stopCh:
					return
				case dataCh <- value:
				}
			}
		}(strconv.Itoa(i))
	}

	// получатели
	for i := 0; i < NumReceivers; i++ {
		go func(id string) {
			defer wgReceivers.Done()

			for {
				// Так же, как горутина отправителя, операция
				// try-receive здесь предназначена для
				// попытки выйти из горутины получателя
				// как можно раньше.

				select {
				case <- stopCh:
					return
				default:
				}

				// Даже если stopCh закрыт, первая ветка
				// в этом блоке select может быть
				// все еще не выбрана для некоторых циклов
				// (и навсегда в теории), если получение
				// из dataCh также не блокируется. Если
				// это неприемлемо, то вышеуказанная
				// операция try-receive обязательна.

				select {
				case <- stopCh:
					return
				case value := <-dataCh:
					if value == Max-1 {
						// Здесь используется тот же трюк
						// для уведомления модератора
						// закрыть дополнительный
						// сигнальный канал.

						select {
						case toStop <- "receiver#" + id:
						default:
						}
						return
					}

					log.Println(value)
				}
			}
		}(strconv.Itoa(i))
	}

	// ...
	wgReceivers.Wait()

	log.Println("stopped by", stoppedBy)
}
```

В этом примере принцип закрытия каналов все еще соблюдается.

Обратите внимание, что размер буфера (емкость) канала `toStop` равен одному. Это необходимо, чтобы избежать пропуска первого уведомления, когда оно отправляется до того, как горутина модератора будет готова получить уведомление из `toStop`.

Мы также можем установить емкость канала `toStop` равной сумме количества отправителей и получателей, тогда нам не нужен блок try-send select для уведомления модератора.

```go
...
toStop := make(chan string, NumReceivers + NumSenders)
...
			value := rand.Intn(Max)
			if value == 0 {
				toStop <- "sender#" + id
				return
			}
...
				if value == Max-1 {
					toStop <- "receiver#" + id
					return
				}
...
```

### 4. Вариант ситуации "M получателей, один отправитель": запрос на закрытие сделан горутиной третьей стороны

Иногда требуется, чтобы сигнал закрытия был сделан горутиной третьей стороны. Для таких случаев мы можем использовать дополнительный сигнальный канал для уведомления отправителя закрыть канал данных. Например,

```go
package main

import (
	"time"
	"math/rand"
	"sync"
	"log"
)

func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20
	log.SetFlags(0)

	// ...
	const Max = 100000
	const NumReceivers = 100
	const NumThirdParties = 15
	wgReceivers := sync.WaitGroup{}
	wgReceivers.Add(NumReceivers)

	// ...
	dataCh := make(chan int)
	closing := make(chan struct{}) // сигнальный канал
	closed := make(chan struct{})

	// Функция stop может быть вызвана
	// несколько раз безопасно.
	stop := func() {
		select {
		case closing<-struct{}{}:
			<-closed
		case <-closed:
		}
	}

	// некоторые горутины третьей стороны
	for i := 0; i < NumThirdParties; i++ {
		go func() {
			r := 1 + rand.Intn(3)
			time.Sleep(time.Duration(r) * time.Second)
			stop()
		}()
	}

	// отправитель
	go func() {
		defer func() {
			close(closed)
			close(dataCh)
		}()

		for {
			select{
			case <-closing: return
			default:
			}
			select{
			case <-closing: return
			case dataCh <- rand.Intn(Max):
			}
		}
	}()

	// получатели
	for i := 0; i < NumReceivers; i++ {
		go func() {
			defer wgReceivers.Done()

			for value := range dataCh {
				log.Println(value)
			}
		}()
	}

	wgReceivers.Wait()
}
```

Идея, использованная в функции `stop`, заимствована из комментария, сделанного Роджером Пеппе.

### 5. Вариант ситуации "N отправителей": канал данных должен быть закрыт, чтобы сообщить получателям, что отправка данных завершена

В решениях для вышеуказанных ситуаций с N отправителями, чтобы соблюсти принцип закрытия каналов, мы избегаем закрытия каналов данных. Однако иногда требуется, чтобы каналы данных были закрыты в конце, чтобы получатели знали, что отправка данных завершена. Для таких случаев мы можем преобразовать ситуацию с N отправителями в ситуацию с одним отправителем, используя промежуточный канал. Промежуточный канал имеет только одного отправителя, так что мы можем закрыть его вместо закрытия исходного канала данных.

```go
package main

import (
	"time"
	"math/rand"
	"sync"
	"log"
	"strconv"
)

func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20
	log.SetFlags(0)

	// ...
	const Max = 1000000
	const NumReceivers = 10
	const NumSenders = 1000
	const NumThirdParties = 15
	wgReceivers := sync.WaitGroup{}
	wgReceivers.Add(NumReceivers)

	// ...
	dataCh := make(chan int)     // будет закрыт
	middleCh := make(chan int)   // никогда не будет закрыт
	closing := make(chan string) // сигнальный канал
	closed := make(chan struct{})

	var stoppedBy string

	// Функция stop может быть вызвана
	// несколько раз безопасно.
	stop := func(by string) {
		select {
		case closing <- by:
			<-closed
		case <-closed:
		}
	}

	// промежуточный слой
	go func() {
		exit := func(v int, needSend bool) {
			close(closed)
			if needSend {
				dataCh <- v
			}
			close(dataCh)
		}

		for {
			select {
			case stoppedBy = <-closing:
				exit(0, false)
				return
			case v := <- middleCh:
				select {
				case stoppedBy = <-closing:
					exit(v, true)
					return
				case dataCh <- v:
				}
			}
		}
	}()

	// некоторые горутины третьей стороны
	for i := 0; i < NumThirdParties; i++ {
		go func(id string) {
			r := 1 + rand.Intn(3)
			time.Sleep(time.Duration(r) * time.Second)
			stop("3rd-party#" + id)
		}(strconv.Itoa(i))
	}

	// отправители
	for i := 0; i < NumSenders; i++ {
		go func(id string) {
			for {
				value := rand.Intn(Max)
				if value == 0 {
					stop("sender#" + id)
					return
				}

				select {
				case <- closed:
					return
				default:
				}

				select {
				case <- closed:
					return
				case middleCh <- value:
				}
			}
		}(strconv.Itoa(i))
	}

	// получатели
	for range [NumReceivers]struct{}{} {
		go func() {
			defer wgReceivers.Done()

			for value := range dataCh {
				log.Println(value)
			}
		}()
	}

	// ...
	wgReceivers.Wait()

	log.Println("stopped by", stoppedBy)
}
```

## Больше ситуаций?

Должно быть больше вариантов ситуаций, но вышеуказанные — самые распространенные и основные. Используя каналы (и другие техники конкурентного программирования) умно, я верю, что решение, соблюдающее принцип закрытия каналов для каждого варианта ситуации, всегда можно найти.

## Заключение

Нет ситуаций, которые заставят вас нарушить принцип закрытия каналов. Если вы столкнетесь с такой ситуацией, пожалуйста, пересмотрите свой дизайн и перепишите код.

Программирование с каналами Go — это как создание искусства.

---

**Источник:** [How to Gracefully Close Channels - Go 101](https://go101.org/article/channel-closing.html)

