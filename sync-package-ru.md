# Техники синхронизации конкурентности, предоставляемые в стандартном пакете `sync`

В статье о случаях использования каналов представлено множество случаев использования каналов для синхронизации данных между горутинами. На самом деле, каналы — не единственная техника синхронизации, предоставляемая в Go. Есть и другие техники синхронизации, поддерживаемые в Go. Для некоторых определенных обстоятельств использование техник синхронизации, отличных от каналов, более эффективно и читаемо, чем использование каналов. Ниже будут представлены техники синхронизации, предоставляемые в стандартном пакете `sync`.

Стандартный пакет `sync` предоставляет несколько типов, которые можно использовать для синхронизации в некоторых специализированных обстоятельствах и гарантировать некоторые специализированные порядки памяти. Для специализированных обстоятельств эти техники более эффективны и выглядят чище, чем способы с каналами.

(Обратите внимание, чтобы избежать аномального поведения, лучше никогда не копировать значения типов в стандартном пакете `sync`.)

## Тип `sync.WaitGroup`

Каждое значение `sync.WaitGroup` поддерживает счетчик внутри. Начальное значение счетчика — ноль.

Тип `*WaitGroup` имеет основные методы: `Add(delta int)`, `Done()`, `Wait()` и (начиная с Go 1.25) `Go(f func())`.

Для адресуемого значения `WaitGroup` `wg`:

* мы можем вызвать метод `wg.Add(delta)`, чтобы изменить значение счетчика, поддерживаемое `wg`.
* вызов метода `wg.Done()` полностью эквивалентен вызову метода `wg.Add(-1)`.
* если вызов `wg.Add(delta)` (или `wg.Done()`) изменяет счетчик, поддерживаемый `wg`, на отрицательное значение, произойдет паника.
* когда горутина вызывает `wg.Wait()`,  
   * если счетчик, поддерживаемый `wg`, уже равен нулю, то вызов `wg.Wait()` можно рассматривать как no-op.  
   * иначе (счетчик положительный), горутина войдет в заблокированное состояние. Она снова войдет в состояние выполнения (т.е., вызов `wg.Wait()` вернется), когда другая горутина изменит счетчик на ноль, обычно путем вызова `wg.Done()`.

Обратите внимание, что `wg.Add(delta)`, `wg.Done()` и `wg.Wait()` являются сокращениями для `(&wg).Add(delta)`, `(&wg).Done()` и `(&wg).Wait()` соответственно.

### Метод `Go()` в Go 1.25

Начиная с Go 1.25, тип `*WaitGroup` также имеет метод `Go(f func())`, который упрощает использование `WaitGroup`. Метод `wg.Go(f)` автоматически:
1. Вызывает `wg.Add(1)` перед запуском функции `f` в новой горутине
2. Вызывает `wg.Done()` после завершения функции `f`

Это делает код более чистым и менее подверженным ошибкам, так как избавляет от необходимости вручную вызывать `Add(1)` и `Done()`. Пример использования:

```go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

func main() {
	var n int32
	var wg sync.WaitGroup
	
	for range 1000 {
		wg.Go(func() {
			atomic.AddInt32(&n, 1)
		})
	}
	
	wg.Wait()
	fmt.Println(atomic.LoadInt32(&n)) // 1000
}
```

Этот код эквивалентен более старому стилю:

```go
var wg sync.WaitGroup
wg.Add(1000)
for i := 0; i < 1000; i++ {
	go func() {
		defer wg.Done()
		atomic.AddInt32(&n, 1)
	}()
}
wg.Wait()
```

Метод `Go()` особенно удобен в сочетании с циклом `for range`, который был добавлен в Go 1.22 для итерации по целым числам.

Обычно значение `WaitGroup` используется для сценария, когда одна горутина ждет, пока все из нескольких других горутин завершат свои соответствующие задачи. Пример (классический подход):

```go
package main

import (
	"log"
	"math/rand"
	"sync"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20

	const N = 5
	var values [N]int32

	var wg sync.WaitGroup
	wg.Add(N)
	for i := 0; i < N; i++ {
		i := i
		go func() {
			values[i] = 50 + rand.Int31n(50)
			log.Println("Done:", i)
			wg.Done() // <=> wg.Add(-1)
		}()
	}

	wg.Wait()
	// Все элементы теперь гарантированно
	// инициализированы.
	log.Println("values:", values)
}
```

В приведенном выше примере основная горутина ждет, пока все остальные `N` горутин заполнят свои соответствующие значения элементов в массиве `values`. Вот один из возможных результатов вывода:

Done: 4
Done: 1
Done: 3
Done: 0
Done: 2
values: [71 89 50 62 60]

Мы можем разделить единственный вызов метода `Add` в приведенном выше примере на несколько.

```go
...
	var wg sync.WaitGroup
	for i := 0; i < N; i++ {
		wg.Add(1) // будет вызван N раз
		i := i
		go func() {
			values[i] = 50 + rand.Int31n(50)
			wg.Done()
		}()
	}
...
```

Метод `Wait` может быть вызван в нескольких горутинах. Когда счетчик станет равен нулю, все они будут уведомлены, в режиме широковещательной передачи.

```go
func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20

	const N = 5
	var values [N]int32

	var wgA, wgB sync.WaitGroup
	wgA.Add(N)
	wgB.Add(1)

	for i := 0; i < N; i++ {
		i := i
		go func() {
			wgB.Wait() // ждать уведомления
			log.Printf("values[%v]=%v \n", i, values[i])
			wgA.Done()
		}()
	}

	// Цикл гарантированно завершится до того,
	// как любой из вышеуказанных вызовов wg.Wait вернется.
	for i := 0; i < N; i++ {
		values[i] = 50 + rand.Int31n(50)
	}
	// Сделать широковещательное уведомление.
	wgB.Done()
	wgA.Wait()
}
```

Значение `WaitGroup` может быть повторно использовано после того, как один вызов его метода `Wait` вернется. Но обратите внимание, что каждый вызов метода `Add` с положительной дельтой, который происходит, когда счетчик равен нулю, должен произойти до того, как любой вызов `Wait` начнется, иначе могут возникнуть гонки данных.

## Тип `sync.Once`

Значение `*sync.Once` имеет метод `Do(f func())`, который принимает единственный параметр типа `func()`.

Для адресуемого значения `Once` `o`, вызов метода `o.Do()`, который является сокращением для `(&o).Do()`, может быть конкурентно выполнен несколько раз, в нескольких горутинах. Аргументы этих вызовов `o.Do()` должны (но не обязаны) быть одним и тем же значением функции.

Среди этих вызовов методов `o.Do`, будет вызвана ровно одна функция-аргумент. Вызванная функция-аргумент гарантированно завершится до того, как любой вызов метода `o.Do` вернется. Другими словами, код в вызванной функции-аргументе гарантированно будет выполнен до того, как любой вызов метода `o.Do` вернется.

Обычно значение `Once` используется для обеспечения того, чтобы часть кода была выполнена ровно один раз в конкурентном программировании.

Пример:

```go
package main

import (
	"log"
	"sync"
)

func main() {
	log.SetFlags(0)

	x := 0
	doSomething := func() {
		x++
		log.Println("Hello")
	}

	var wg sync.WaitGroup
	var once sync.Once
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			once.Do(doSomething)
			log.Println("world!")
		}()
	}

	wg.Wait()
	log.Println("x =", x) // x = 1
}
```

В приведенном выше примере `Hello` будет напечатано один раз, но `world!` будет напечатано пять раз. И `Hello` гарантированно будет напечатано перед всеми пятью `world!`.

## Типы `sync.Mutex` и `sync.RWMutex`

Оба типа `*sync.Mutex` и `*sync.RWMutex` реализуют интерфейс `sync.Locker`. Поэтому они оба имеют два метода, `Lock` и `Unlock`, чтобы предотвратить одновременное использование части данных несколькими пользователями данных.

Кроме методов `Lock` и `Unlock`, тип `*RWMutex` имеет еще два метода, `RLock` и `RUnlock`, чтобы избежать одновременного использования части данных некоторыми пользователями данных (либо писателями, либо читателями) и одним писателем данных, но разрешить некоторым читателям данных одновременно получать доступ к части данных.

(Примечание, здесь терминологии "читатель данных" и "писатель данных" не следует интерпретировать буквально. Они используются только для целей объяснения. Читатель данных может изменять данные, а писатель данных может только читать данные.)

Значение `Mutex` часто называется взаимно исключающей блокировкой (mutual exclusion lock). Нулевое значение `Mutex` — это разблокированный мьютекс. Значение `Mutex` может быть заблокировано только тогда, когда оно находится в разблокированном состоянии. Другими словами, как только адресуемое значение `Mutex` `m` успешно заблокировано (т.е., вызов метода `m.Lock()` возвращается), новая попытка горутины заблокировать значение `Mutex` заставит горутину войти в заблокированное состояние, пока значение `Mutex` не будет разблокировано (через последующий вызов `m.Unlock()`).

Обратите внимание, что после того, как мьютекс был успешно заблокирован горутиной, только эта горутина может разблокировать мьютекс позже, иначе произойдет паника. Блокировка мьютекса в одной горутине и разблокировка его в другой горутине недопустимы.

Пример использования `Mutex`:

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	var m sync.Mutex
	var n int64

	var wg sync.WaitGroup
	wg.Add(2)
	go func() {
		defer wg.Done()
		for i := 0; i < 3; i++ {
			m.Lock()
			n++
			fmt.Println("goroutine 1:", n)
			m.Unlock()
			time.Sleep(time.Millisecond)
		}
	}()
	go func() {
		defer wg.Done()
		for i := 0; i < 3; i++ {
			m.Lock()
			n++
			fmt.Println("goroutine 2:", n)
			m.Unlock()
			time.Sleep(time.Millisecond)
		}
	}()

	wg.Wait()
	fmt.Println("final n:", n)
}
```

Нулевое значение `RWMutex` является разблокированным RWMutex. Значение `RWMutex` также является взаимно исключающей блокировкой. Но значение `RWMutex` имеет два типа блокировок: блокировка записи (write lock) и блокировка чтения (read lock).

* Заблокировать мьютекс для записи означает получить исключительное право на использование защищаемых данных. Когда `RWMutex` мьютекс заблокирован для записи, любые попытки заблокировать его для записи или чтения приведут к блокировке попыток до тех пор, пока блокировка записи не будет снята.
* Заблокировать мьютекс для чтения означает получить общее право на использование защищаемых данных. Когда `RWMutex` мьютекс заблокирован для чтения (возможно, несколькими горутинами), любая попытка заблокировать его для записи приведет к блокировке попытки до тех пор, пока все блокировки чтения не будут сняты. Но новые попытки заблокировать мьютекс для чтения все еще могут быть успешными. Другими словами, блокировка чтения совместно используется между несколькими читателями.

Для адресуемого `RWMutex` значения `rw`:

* `rw.Lock()` и `rw.Unlock()` используются для блокировки и разблокировки мьютекса для записи.
* `rw.RLock()` и `rw.RUnlock()` используются для блокировки и разблокировки мьютекса для чтения.
* `rw.RLocker()` возвращает значение, которое реализует интерфейс `sync.Locker` и представляет блокировку чтения `rw`.

Обратите внимание, что каждый вызов `Lock()` или `RLock()` должен иметь соответствующий вызов `Unlock()` или `RUnlock()`. Иначе мьютекс останется заблокированным, и любые последующие попытки заблокировать мьютекс будут блокироваться навсегда (возможна взаимная блокировка).

Пример использования `RWMutex`:

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	var m sync.RWMutex
	var n int64

	var wg sync.WaitGroup
	wg.Add(3)

	// Писатель
	go func() {
		defer wg.Done()
		for i := 0; i < 3; i++ {
			m.Lock()
			n++
			fmt.Println("writer:", n)
			m.Unlock()
			time.Sleep(time.Millisecond)
		}
	}()

	// Читатели
	for i := 0; i < 2; i++ {
		go func(id int) {
			defer wg.Done()
			for j := 0; j < 3; j++ {
				m.RLock()
				fmt.Printf("reader %d: %d\n", id, n)
				m.RUnlock()
				time.Sleep(time.Millisecond)
			}
		}(i)
	}

	wg.Wait()
}
```

Обратите внимание, что мьютексы не являются рекурсивными (или перезаписываемыми). Это означает, что повторная блокировка одного и того же мьютекса в той же горутине приведет к взаимной блокировке (deadlock). Например:

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var m sync.Mutex
	m.Lock()
	fmt.Println("первая блокировка")
	m.Lock() // взаимная блокировка
	fmt.Println("вторая блокировка")
	m.Unlock()
	m.Unlock()
}
```

## Тип `sync.Cond`

Тип `*sync.Cond` имеет три метода: `Wait()`, `Signal()` и `Broadcast()`. Каждое значение `*sync.Cond` поддерживает поле `L` типа `sync.Locker`. Обычно значение поля `L` — это значение `*sync.Mutex` или `*sync.RWMutex`.

Для адресуемого значения `Cond` `c`:

* `c.L` должен быть заблокирован перед вызовом `c.Wait()`. `c.Wait()` сначала разблокирует `c.L`, затем блокирует текущую горутину и делает так, чтобы текущая горутина перешла в состояние ожидания уведомления. Когда текущая горутина будет разбужена другим вызовом `c.Signal()` или `c.Broadcast()`, `c.Wait()` снова заблокирует `c.L`, затем вернется. Поэтому `c.Wait()` блокирует `c.L` как при входе, так и при выходе.
* `c.Signal()` разбудит одну ожидающую горутину, если такая есть. Если ожидающих горутин нет, вызов `c.Signal()` не сделает ничего.
* `c.Broadcast()` разбудит все ожидающие горутины. Если ожидающих горутин нет, вызов `c.Broadcast()` не сделает ничего.

Обычно одна горутина ждет изменений определенного условия, а некоторые другие горутины изменяют условие и отправляют уведомления. Вот пример:

```go
package main

import (
	"fmt"
	"math/rand"
	"sync"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20

	const N = 10
	var values [N]string

	cond := sync.NewCond(&sync.Mutex{})

	for i := 0; i < N; i++ {
		d := time.Second * time.Duration(rand.Intn(10)) / 10
		go func(i int) {
			time.Sleep(d) // имитация нагрузки

			// Изменения должны быть сделаны, когда
			// cond.L заблокирован.
			cond.L.Lock()
			values[i] = string('a' + i)

			// Уведомить, когда блокировка cond.L установлена.
			cond.Broadcast()
			cond.L.Unlock()

			// "cond.Broadcast()" также может быть помещен
			// здесь, когда блокировка cond.L разблокирована.
			//cond.Broadcast()
		}(i)
	}

	// Эта функция должна быть вызвана, когда
	// cond.L заблокирован.
	checkCondition := func() bool {
		fmt.Println(values)
		for i := 0; i < N; i++ {
			if values[i] == "" {
				return false
			}
		}
		return true
	}

	cond.L.Lock()
	defer cond.L.Unlock()
	for !checkCondition() {
		// Должен быть вызван, когда cond.L заблокирован.
		cond.Wait()
	}
}
```

Один из возможных результатов вывода:

[         ]
[     f    ]
[  c   f    ]
[  c   f  h  ]
[ b c   f  h  ]
[a b c   f  h  j]
[a b c   f g h i j]
[a b c  e f g h i j]
[a b c d e f g h i j]

Поскольку в этом примере только одна горутина (основная горутина) ждет разблокировки, вызов `cond.Broadcast()` может быть заменен на `cond.Signal()`. Как предполагают комментарии, `cond.Broadcast()` и `cond.Signal()` не обязаны вызываться, когда `cond.L` заблокирован.

Чтобы избежать гонок данных, каждая из десяти частей пользовательского условия должна изменяться только тогда, когда `cond.L` заблокирован. Функция `checkCondition` и метод `cond.Wait` также должны вызываться, когда `cond.L` заблокирован.

На самом деле, для указанного выше примера поле `cond.L` также может быть значением `*sync.RWMutex`, и каждая из десяти частей пользовательского условия может быть изменена, когда удерживается блокировка чтения `cond.L`, как показывает следующий код:

```go
...
	cond := sync.NewCond(&sync.RWMutex{})
	cond.L.Lock()

	for i := 0; i < N; i++ {
		d := time.Second * time.Duration(rand.Intn(10)) / 10
		go func(i int) {
			time.Sleep(d)
			cond.L.(*sync.RWMutex).RLock()
			values[i] = string('a' + i)
			cond.L.(*sync.RWMutex).RUnlock()
			cond.Signal()
		}(i)
	}
...
```

В приведенном выше примере значение `sync.RWMutex` используется необычно. Его блокировка чтения удерживается некоторыми горутинами, которые изменяют элементы массива, а его блокировка записи используется основной горутиной для чтения элементов массива.

Пользовательское условие, отслеживаемое значением `Cond`, может быть пустым. В таких случаях значение `Cond` используется только для уведомлений. Например, следующая программа напечатает `abc` или `bac`.

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	wg := sync.WaitGroup{}
	wg.Add(1)
	cond := sync.NewCond(&sync.Mutex{})
	cond.L.Lock()
	go func() {
		cond.L.Lock()
		go func() {
			cond.L.Lock()
			cond.Broadcast()
			cond.L.Unlock()
		}()
		cond.Wait()
		fmt.Print("a")
		cond.L.Unlock()
		wg.Done()
	}()
	cond.Wait()
	fmt.Print("b")
	cond.L.Unlock()
	wg.Wait()
	fmt.Println("c")
}
```

При необходимости несколько значений `sync.Cond` могут совместно использовать один и тот же `sync.Locker`. Однако такие случаи редко встречаются на практике.

---

**Источник:** [Concurrency Synchronization Techniques Provided in the `sync` Standard Package - Go 101](https://go101.org/article/concurrent-synchronization-more.html)

