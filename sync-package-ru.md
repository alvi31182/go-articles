# Техники синхронизации конкурентности, предоставляемые в стандартном пакете `sync`

В статье о случаях использования каналов представлено множество случаев использования каналов для синхронизации данных между горутинами. На самом деле, каналы — не единственная техника синхронизации, предоставляемая в Go. Есть и другие техники синхронизации, поддерживаемые в Go. Для некоторых определенных обстоятельств использование техник синхронизации, отличных от каналов, более эффективно и читаемо, чем использование каналов. Ниже будут представлены техники синхронизации, предоставляемые в стандартном пакете `sync`.

Стандартный пакет `sync` предоставляет несколько типов, которые можно использовать для синхронизации в некоторых специализированных обстоятельствах и гарантировать некоторые специализированные порядки памяти. Для специализированных обстоятельств эти техники более эффективны и выглядят чище, чем способы с каналами.

(Обратите внимание, чтобы избежать аномального поведения, лучше никогда не копировать значения типов в стандартном пакете `sync`.)

## Тип `sync.WaitGroup`

Каждое значение `sync.WaitGroup` поддерживает счетчик внутри. Начальное значение счетчика — ноль.

Тип `*WaitGroup` имеет три метода: `Add(delta int)`, `Done()` и `Wait()`.

Для адресуемого значения `WaitGroup` `wg`:

* мы можем вызвать метод `wg.Add(delta)`, чтобы изменить значение счетчика, поддерживаемое `wg`.
* вызов метода `wg.Done()` полностью эквивалентен вызову метода `wg.Add(-1)`.
* если вызов `wg.Add(delta)` (или `wg.Done()`) изменяет счетчик, поддерживаемый `wg`, на отрицательное значение, произойдет паника.
* когда горутина вызывает `wg.Wait()`,
   * если счетчик, поддерживаемый `wg`, уже равен нулю, то вызов `wg.Wait()` можно рассматривать как no-op.
   * иначе (счетчик положительный), горутина войдет в заблокированное состояние. Она снова войдет в состояние выполнения (т.е., вызов `wg.Wait()` вернется), когда другая горутина изменит счетчик на ноль, обычно путем вызова `wg.Done()`.

Обратите внимание, что `wg.Add(delta)`, `wg.Done()` и `wg.Wait()` являются сокращениями для `(&wg).Add(delta)`, `(&wg).Done()` и `(&wg).Wait()` соответственно.

Обычно значение `WaitGroup` используется для сценария, когда одна горутина ждет, пока все из нескольких других горутин завершат свои соответствующие задачи. Пример:

```go
package main

import (
	"log"
	"math/rand"
	"sync"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20

	const N = 5
	var values [N]int32

	var wg sync.WaitGroup
	wg.Add(N)
	for i := 0; i < N; i++ {
		i := i
		go func() {
			values[i] = 50 + rand.Int31n(50)
			log.Println("Done:", i)
			wg.Done() // <=> wg.Add(-1)
		}()
	}

	wg.Wait()
	// Все элементы теперь гарантированно
	// инициализированы.
	log.Println("values:", values)
}
```

В приведенном выше примере основная горутина ждет, пока все остальные `N` горутин заполнят свои соответствующие значения элементов в массиве `values`. Вот один из возможных результатов вывода:

```
Done: 4
Done: 1
Done: 3
Done: 0
Done: 2
values: [71 89 50 62 60]
```

Мы можем разделить единственный вызов метода `Add` в приведенном выше примере на несколько.

```go
...
	var wg sync.WaitGroup
	for i := 0; i < N; i++ {
		wg.Add(1) // будет вызван N раз
		i := i
		go func() {
			values[i] = 50 + rand.Int31n(50)
			wg.Done()
		}()
	}
...
```

Метод `Wait` может быть вызван в нескольких горутинах. Когда счетчик станет равен нулю, все они будут уведомлены, в режиме широковещательной передачи.

```go
func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20

	const N = 5
	var values [N]int32

	var wgA, wgB sync.WaitGroup
	wgA.Add(N)
	wgB.Add(1)

	for i := 0; i < N; i++ {
		i := i
		go func() {
			wgB.Wait() // ждать уведомления
			log.Printf("values[%v]=%v \n", i, values[i])
			wgA.Done()
		}()
	}

	// Цикл гарантированно завершится до того,
	// как любой из вышеуказанных вызовов wg.Wait вернется.
	for i := 0; i < N; i++ {
		values[i] = 50 + rand.Int31n(50)
	}
	// Сделать широковещательное уведомление.
	wgB.Done()
	wgA.Wait()
}
```

Значение `WaitGroup` может быть повторно использовано после того, как один вызов его метода `Wait` вернется. Но обратите внимание, что каждый вызов метода `Add` с положительной дельтой, который происходит, когда счетчик равен нулю, должен произойти до того, как любой вызов `Wait` начнется, иначе могут возникнуть гонки данных.

## Тип `sync.Once`

Значение `*sync.Once` имеет метод `Do(f func())`, который принимает единственный параметр типа `func()`.

Для адресуемого значения `Once` `o`, вызов метода `o.Do()`, который является сокращением для `(&o).Do()`, может быть конкурентно выполнен несколько раз, в нескольких горутинах. Аргументы этих вызовов `o.Do()` должны (но не обязаны) быть одним и тем же значением функции.

Среди этих вызовов методов `o.Do`, будет вызвана ровно одна функция-аргумент. Вызванная функция-аргумент гарантированно завершится до того, как любой вызов метода `o.Do` вернется. Другими словами, код в вызванной функции-аргументе гарантированно будет выполнен до того, как любой вызов метода `o.Do` вернется.

Обычно значение `Once` используется для обеспечения того, чтобы часть кода была выполнена ровно один раз в конкурентном программировании.

Пример:

```go
package main

import (
	"log"
	"sync"
)

func main() {
	log.SetFlags(0)

	x := 0
	doSomething := func() {
		x++
		log.Println("Hello")
	}

	var wg sync.WaitGroup
	var once sync.Once
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			once.Do(doSomething)
			log.Println("world!")
		}()
	}

	wg.Wait()
	log.Println("x =", x) // x = 1
}
```

В приведенном выше примере `Hello` будет напечатано один раз, но `world!` будет напечатано пять раз. И `Hello` гарантированно будет напечатано перед всеми пятью `world!`.

## Типы `sync.Mutex` и `sync.RWMutex`

Оба типа `*sync.Mutex` и `*sync.RWMutex` реализуют интерфейс `sync.Locker`. Поэтому они оба имеют два метода, `Lock` и `Unlock`, чтобы предотвратить одновременное использование части данных несколькими пользователями данных.

Кроме методов `Lock` и `Unlock`, тип `*RWMutex` имеет еще два метода, `RLock` и `RUnlock`, чтобы избежать одновременного использования части данных некоторыми пользователями данных (либо писателями, либо читателями) и одним писателем данных, но разрешить некоторым читателям данных одновременно получать доступ к части данных.

(Примечание, здесь терминологии "читатель данных" и "писатель данных" не следует интерпретировать буквально. Они используются только для целей объяснения. Читатель данных может изменять данные, а писатель данных может только читать данные.)

Значение `Mutex` часто называется взаимно исключающей блокировкой (mutual exclusion lock). Нулевое значение `Mutex` — это разблокированный мьютекс. Значение `Mutex` может быть заблокировано только тогда, когда оно находится в разблокированном состоянии. Другими словами, как только адресуемое значение `Mutex` `m` успешно заблокировано (т.е., вызов метода `m.Lock()` возвращается), новая попытка горутины заблокировать значение `Mutex` заставит горутину войти в заблокированное состояние, пока значение `Mutex` не будет разблокировано (через последующий вызов `m.Unlock()`).

Обратите внимание, что `m.Lock()` и `m.Unlock()` являются сокращениями для `(&m).Lock()` и `(&m).Unlock()` соответственно.

Пример использования `sync.Mutex`:

```go
package main

import (
	"fmt"
	"runtime"
	"sync"
)

type Counter struct {
	m sync.Mutex
	n uint64
}

func (c *Counter) Value() uint64 {
	c.m.Lock()
	defer c.m.Unlock()
	return c.n
}

func (c *Counter) Increase(delta uint64) {
	c.m.Lock()
	c.n += delta
	c.m.Unlock()
}

func main() {
	var c Counter
	for i := 0; i < 100; i++ {
		go func() {
			for k := 0; k < 100; k++ {
				c.Increase(1)
			}
		}()
	}

	// Цикл только для демонстрации.
	for c.Value() < 10000 {
		runtime.Gosched()
	}
	fmt.Println(c.Value()) // 10000
}
```

В приведенном выше примере значение `Counter` использует поле `Mutex` для гарантии того, что поле `n` значения `Counter` никогда не будет использоваться несколькими горутинами одновременно.

Значение `RWMutex` часто называется блокировкой взаимного исключения читатель+писатель (reader+writer mutual exclusion lock). Оно имеет две блокировки: блокировку записи и блокировку чтения. Блокировки нулевого значения `RWMutex` обе разблокированы. Для адресуемого значения `RWMutex` `rwm`, писатели данных могут заблокировать блокировку записи `rwm` через вызовы метода `rwm.Lock()`, а читатели данных могут заблокировать блокировку чтения `rwm` через вызовы метода `rwm.RLock()`. Вызовы методов `rwm.Unlock()` и `rwm.RUnlock()` используются для разблокировки блокировок записи и чтения `rwm`. Блокировка чтения `rwm` поддерживает счетчик блокировок, который увеличивается на единицу, когда `rwm.Lock()` вызывается успешно, и уменьшается на единицу, когда `rwm.Unlock()` вызывается успешно. Нулевой счетчик блокировок означает, что блокировка чтения находится в разблокированном состоянии, а ненулевой (должен быть больше единицы) означает, что блокировка чтения заблокирована.

Обратите внимание, что `rwm.Lock()`, `rwm.Unlock()`, `rwm.RLock()` и `rwm.RUnlock()` являются сокращениями для `(&m).Lock()`, `(&m).Unlock()`, `(&m).RLock()` и `(&m).RUnlock()` соответственно.

Для адресуемого значения `RWMutex` `rwm` существуют следующие правила.

Блокировка записи `rwm` может быть заблокирована только если ни блокировка чтения, ни блокировка записи `rwm` не находятся в заблокированном состоянии. Другими словами, блокировка записи `rwm` может удерживаться максимум одним писателем в любой момент времени, и блокировки чтения и записи `rwm` не могут удерживаться одновременно.

Когда блокировка записи `rwm` находится в заблокированном состоянии, любые новые попытки заблокировать блокировку записи или блокировку чтения `rwm` будут заблокированы до тех пор, пока начальная блокировка записи не будет разблокирована.

Когда блокировка чтения `rwm` находится в заблокированном состоянии, любые новые попытки заблокировать блокировку записи будут заблокированы до тех пор, пока блокировка чтения не будет разблокирована. Однако новые попытки заблокировать блокировку чтения все еще могут быть успешными, если попытки выполняются до любых заблокированных попыток заблокировать блокировку записи (см. следующее правило для подробностей). Другими словами, блокировка чтения может удерживаться более чем одним читателем одновременно. Блокировка чтения вернется в разблокированное состояние, когда ее счетчик блокировок вернется к нулю.

Предполагая, что блокировка чтения значения `rwm` сейчас находится в заблокированном состоянии, чтобы избежать бесконечной блокировки чтения, любые новые попытки заблокировать блокировку чтения после заблокированной попытки заблокировать блокировку записи будут заблокированы.

Предполагая, что блокировка записи значения `rwm` сейчас находится в заблокированном состоянии, для официального стандартного компилятора Go, чтобы избежать бесконечной блокировки записи, попытки заблокировать блокировку чтения перед освобождением блокировки записи обязательно будут успешными, как только блокировка записи будет разблокирована, даже если некоторые из попыток сделаны после некоторых все еще заблокированных попыток заблокировать блокировку записи.

Последние два правила предназначены для обеспечения того, чтобы и читатели, и писатели имели шансы получить блокировки.

Обратите внимание, блокировки не привязаны к горутинам. Блокировка может быть заблокирована в одной горутине и разблокирована в другой позже. Другими словами, блокировка не знает, какая горутина успешно заблокировала или разблокировала ее.

Тип поля `m` типа `Counter` в последнем примере может быть изменен на `sync.RWMutex`, как показывает следующий код, чтобы получить лучшую производительность, когда метод `Value` вызывается очень часто, но метод `Increase` вызывается не часто.

```go
...
type Counter struct {
	//m sync.Mutex
	m sync.RWMutex
	n uint64
}

func (c *Counter) Value() uint64 {
	//c.m.Lock()
	//defer c.m.Unlock()
	c.m.RLock()
	defer c.m.RUnlock()
	return c.n
}
...
```

Другой сценарий использования значений `sync.RWMutex` — это разделение работы записи на несколько небольших. Пожалуйста, прочитайте следующий раздел для примера.

Благодаря последним двум правилам, упомянутым выше, следующая программа очень вероятно выведет `abdc`.

```go
package main

import (
	"fmt"
	"time"
	"sync"
)

func main() {
	var m sync.RWMutex

	go func() {
		m.RLock()
		fmt.Print("a")
		time.Sleep(time.Second)
		m.RUnlock()
	}()

	go func() {
		time.Sleep(time.Second * 1 / 4)
		m.Lock()
		fmt.Print("b")
		time.Sleep(time.Second)
		m.Unlock()
	}()

	go func() {
		time.Sleep(time.Second * 2 / 4)
		m.Lock()
		fmt.Print("c")
		m.Unlock()
	}()

	go func () {
		time.Sleep(time.Second * 3 / 4)
		m.RLock()
		fmt.Print("d")
		m.RUnlock()
	}()

	time.Sleep(time.Second * 3)
	fmt.Println()
}
```

Обратите внимание, приведенный выше пример предназначен только для объяснения. Он использует вызовы `time.Sleep` для синхронизации конкурентности, что является плохой практикой для производственного кода.

Значения `sync.Mutex` и `sync.RWMutex` также могут использоваться для создания уведомлений, хотя есть много других лучших способов выполнить ту же задачу. Вот пример, который создает уведомление, используя значение `sync.Mutex`.

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	var m sync.Mutex
	m.Lock()

	go func() {
		time.Sleep(time.Second)
		fmt.Println("Hi")
		m.Unlock() // создать уведомление
	}()

	m.Lock() // ждать уведомления
	fmt.Println("Bye")
}
```

В приведенном выше примере текст `Hi` гарантированно будет напечатан перед текстом `Bye`. О гарантиях порядка памяти, предоставляемых значениями `sync.Mutex` и `sync.RWMutex`, пожалуйста, прочитайте [гарантии порядка памяти в Go](memory-model-ru.md).

## Тип `sync.Cond`

Тип `sync.Cond` предоставляет эффективный способ создания уведомлений между горутинами.

Каждое значение `sync.Cond` содержит поле `L` типа `sync.Locker` с именем `L`. Значение поля часто является значением типа `*sync.Mutex` или `*sync.RWMutex`.

Тип `*sync.Cond` имеет три метода: `Wait()`, `Signal()` и `Broadcast()`.

Каждое значение `sync.Cond` также поддерживает очередь ожидающих горутин FIFO (first in first out). Для адресуемого значения `sync.Cond` `c`:

* `c.Wait()` должен быть вызван, когда `c.L` заблокирован, иначе вызов `c.Wait()` вызовет панику. Вызов `c.Wait()` будет:
   * сначала поместить текущую горутину-вызывающую в очередь ожидающих горутин, поддерживаемую `c`,
   * затем вызвать `c.L.Unlock()` для разблокировки/освобождения блокировки `c.L`,
   * затем заставить текущую горутину-вызывающую войти в заблокированное состояние.
   * (Горутина-вызывающая будет разбужена другой горутиной через вызов `c.Signal()` или `c.Broadcast()` позже.)
   * Как только горутина-вызывающая разблокирована и снова входит в состояние выполнения, `c.L.Lock()` будет вызван (в возобновленном вызове `c.Wait()`) для попытки заблокировать и удержать блокировку `c.L` снова. Вызов `c.Wait()` завершится после того, как вызов `c.L.Lock()` вернется.
* вызов `c.Signal()` разбудит первую горутину в очереди ожидающих горутин (и удалит ее из очереди), поддерживаемой `c`, если очередь не пуста.
* вызов `c.Broadcast()` разбудит все горутины в очереди ожидающих горутин (и удалит их из очереди), поддерживаемой `c`, если очередь не пуста.

Обратите внимание, что `c.Wait()`, `c.Signal()` и `c.Broadcast()` являются сокращениями для `(&c).Wait()`, `(&c).Signal()` и `(&c).Broadcast()` соответственно.

`c.Signal()` и `c.Broadcast()` часто используются для уведомления о том, что статус условия изменился. Обычно `c.Wait()` должен вызываться в цикле проверки, удовлетворено ли условие.

В идиоматическом случае использования `sync.Cond`, обычно одна горутина ждет изменений определенного условия, а некоторые другие горутины изменяют условие и отправляют уведомления. Вот пример:

```go
package main

import (
	"fmt"
	"math/rand"
	"sync"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20

	const N = 10
	var values [N]string

	cond := sync.NewCond(&sync.Mutex{})

	for i := 0; i < N; i++ {
		d := time.Second * time.Duration(rand.Intn(10)) / 10
		go func(i int) {
			time.Sleep(d) // имитация нагрузки

			// Изменения должны быть сделаны, когда
			// cond.L заблокирован.
			cond.L.Lock()
			values[i] = string('a' + i)

			// Уведомить, когда блокировка cond.L установлена.
			cond.Broadcast()
			cond.L.Unlock()

			// "cond.Broadcast()" также может быть помещен
			// здесь, когда блокировка cond.L разблокирована.
			//cond.Broadcast()
		}(i)
	}

	// Эта функция должна быть вызвана, когда
	// cond.L заблокирован.
	checkCondition := func() bool {
		fmt.Println(values)
		for i := 0; i < N; i++ {
			if values[i] == "" {
				return false
			}
		}
		return true
	}

	cond.L.Lock()
	defer cond.L.Unlock()
	for !checkCondition() {
		// Должен быть вызван, когда cond.L заблокирован.
		cond.Wait()
	}
}
```

Один из возможных результатов вывода:

```
[         ]
[     f    ]
[  c   f    ]
[  c   f  h  ]
[ b c   f  h  ]
[a b c   f  h  j]
[a b c   f g h i j]
[a b c  e f g h i j]
[a b c d e f g h i j]
```

Поскольку в этом примере только одна горутина (основная горутина) ждет разблокировки, вызов `cond.Broadcast()` может быть заменен на `cond.Signal()`. Как предполагают комментарии, `cond.Broadcast()` и `cond.Signal()` не обязаны вызываться, когда `cond.L` заблокирован.

Чтобы избежать гонок данных, каждая из десяти частей пользовательского условия должна изменяться только тогда, когда `cond.L` заблокирован. Функция `checkCondition` и метод `cond.Wait` также должны вызываться, когда `cond.L` заблокирован.

На самом деле, для указанного выше примера поле `cond.L` также может быть значением `*sync.RWMutex`, и каждая из десяти частей пользовательского условия может быть изменена, когда удерживается блокировка чтения `cond.L`, как показывает следующий код:

```go
...
	cond := sync.NewCond(&sync.RWMutex{})
	cond.L.Lock()

	for i := 0; i < N; i++ {
		d := time.Second * time.Duration(rand.Intn(10)) / 10
		go func(i int) {
			time.Sleep(d)
			cond.L.(*sync.RWMutex).RLock()
			values[i] = string('a' + i)
			cond.L.(*sync.RWMutex).RUnlock()
			cond.Signal()
		}(i)
	}
...
```

В приведенном выше примере значение `sync.RWMutex` используется необычно. Его блокировка чтения удерживается некоторыми горутинами, которые изменяют элементы массива, а его блокировка записи используется основной горутиной для чтения элементов массива.

Пользовательское условие, отслеживаемое значением `Cond`, может быть пустым. В таких случаях значение `Cond` используется только для уведомлений. Например, следующая программа напечатает `abc` или `bac`.

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	wg := sync.WaitGroup{}
	wg.Add(1)
	cond := sync.NewCond(&sync.Mutex{})
	cond.L.Lock()
	go func() {
		cond.L.Lock()
		go func() {
			cond.L.Lock()
			cond.Broadcast()
			cond.L.Unlock()
		}()
		cond.Wait()
		fmt.Print("a")
		cond.L.Unlock()
		wg.Done()
	}()
	cond.Wait()
	fmt.Print("b")
	cond.L.Unlock()
	wg.Wait()
	fmt.Println("c")
}
```

При необходимости несколько значений `sync.Cond` могут совместно использовать один и тот же `sync.Locker`. Однако такие случаи редко встречаются на практике.

---

**Источник:** [Concurrency Synchronization Techniques Provided in the `sync` Standard Package - Go 101](https://go101.org/article/concurrent-synchronization-more.html)
