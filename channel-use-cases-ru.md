# Случаи использования каналов в Go

Перед прочтением этой статьи, пожалуйста, прочитайте статью [каналы в Go](channel-ru.md), которая подробно объясняет типы каналов и их значения. Новичкам в Go может потребоваться прочитать ту статью и текущую несколько раз, чтобы освоить программирование с каналами Go.

Оставшаяся часть этой статьи покажет множество случаев использования каналов. Я надеюсь, что эта статья убедит вас в том, что:

* асинхронное и конкурентное программирование с каналами Go просто и приятно.
* техника синхронизации через каналы имеет более широкий диапазон применений и больше вариаций, чем решения синхронизации, используемые в некоторых других языках, таких как модель акторов и паттерн async/await.

Обратите внимание, что цель этой статьи — показать как можно больше случаев использования каналов. Мы должны понимать, что канал — это не единственная техника синхронизации конкурентности, поддерживаемая в Go, и для некоторых случаев использование каналов может быть не лучшим решением. Пожалуйста, прочитайте [атомарные операции](atomic-operations-ru.md) и [другие техники синхронизации](sync-package-ru.md) для получения дополнительных техник синхронизации конкурентности в Go.

## Использование каналов как Futures/Promises

Futures и promises используются во многих других популярных языках. Они часто ассоциируются с запросами и ответами.

### Возврат каналов только для чтения как результатов

В следующем примере значения двух аргументов вызова функции `sumSquares` запрашиваются конкурентно. Каждая из двух операций приема по каналу будет блокироваться до тех пор, пока операция отправки не выполнится на соответствующем канале. Для возврата окончательного результата требуется около трех секунд вместо шести.

```go
package main

import (
	"time"
	"math/rand"
	"fmt"
)

func longTimeRequest() <-chan int32 {
	r := make(chan int32)

	go func() {
		// Имитация нагрузки.
		time.Sleep(time.Second * 3)
		r <- rand.Int31n(100)
	}()

	return r
}

func sumSquares(a, b int32) int32 {
	return a*a + b*b
}

func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20

	a, b := longTimeRequest(), longTimeRequest()
	fmt.Println(sumSquares(<-a, <-b))
}
```

### Передача каналов только для записи в качестве аргументов

Так же, как в последнем примере, в следующем примере значения двух аргументов вызова функции `sumSquares` запрашиваются конкурентно. В отличие от последнего примера, функция `longTimeRequest` принимает канал только для записи в качестве параметра вместо возврата результата канала только для чтения.

```go
package main

import (
	"time"
	"math/rand"
	"fmt"
)

func longTimeRequest(r chan<- int32)  {
	// Имитация нагрузки.
	time.Sleep(time.Second * 3)
	r <- rand.Int31n(100)
}

func sumSquares(a, b int32) int32 {
	return a*a + b*b
}

func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20

	ra, rb := make(chan int32), make(chan int32)
	go longTimeRequest(ra)
	go longTimeRequest(rb)

	fmt.Println(sumSquares(<-ra, <-rb))
}
```

На самом деле, для указанного выше примера нам не нужны два канала для передачи результатов. Использование одного канала тоже подойдет.

```go
...

	// Канал может быть буферизованным или нет.
	results := make(chan int32, 2)
	go longTimeRequest(results)
	go longTimeRequest(results)

	fmt.Println(sumSquares(<-results, <-results))
}
```

Это своего рода агрегация данных, которая будет специально представлена ниже.

### Первый ответ выигрывает

Это улучшение варианта использования только одного канала из последнего примера.

Иногда часть данных может быть получена из нескольких источников, чтобы избежать высокой задержки. Из-за множества факторов длительность ответов этих источников может сильно различаться. Даже для указанного источника его длительность ответов также не постоянна. Чтобы сделать длительность ответа как можно короче, мы можем отправить запрос каждому источнику в отдельной горутине. Будет использован только первый ответ, остальные более медленные будут отброшены.

Обратите внимание, если есть N источников, емкость канала связи должна быть не менее N-1, чтобы избежать блокировки навсегда горутин, соответствующих отброшенным ответам.

```go
package main

import (
	"fmt"
	"time"
	"math/rand"
)

func source(c chan<- int32) {
	ra, rb := rand.Int31(), rand.Intn(3) + 1
	// Сон 1с/2с/3с.
	time.Sleep(time.Duration(rb) * time.Second)
	c <- ra
}

func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20

	startTime := time.Now()
	// c должен быть буферизованным каналом.
	c := make(chan int32, 5)
	for i := 0; i < cap(c); i++ {
		go source(c)
	}
	// Будет использован только первый ответ.
	rnd := <- c
	fmt.Println(time.Since(startTime))
	fmt.Println(rnd)
}
```

Есть другие способы реализовать случай использования "первый ответ выигрывает", используя механизм select и буферизованный канал с емкостью один. Другие способы будут представлены ниже.

### Дополнительные варианты запрос-ответ

Каналы параметров и результатов могут быть буферизованными, чтобы сторонам ответа не нужно было ждать, пока стороны запроса заберут переданные значения.

Иногда запрос не гарантирует получение валидного значения в ответе. По разным причинам вместо этого может быть возвращена ошибка. Для таких случаев мы можем использовать тип структуры, такой как `struct{v T; err error}` или тип пустого интерфейса в качестве типа элемента канала.

Иногда по некоторым причинам ответ может потребовать гораздо больше времени, чем ожидалось, чтобы прийти, или никогда не придет. Мы можем использовать механизм таймаута, представленный ниже, для обработки таких обстоятельств.

Иногда последовательность значений может быть возвращена со стороны ответа, это своего рода механизм потока данных, упомянутый позже ниже.

## Использование каналов для уведомлений

Уведомления можно рассматривать как особые запросы/ответы, в которых переданные значения не важны. Обычно мы используем тип пустой структуры `struct{}` в качестве типов элементов каналов уведомлений, поскольку размер типа `struct{}` равен нулю, следовательно, значения `struct{}` не потребляют память.

### 1-к-1 уведомление путем отправки значения в канал

Если нет значений для получения из канала, то следующая операция приема по каналу будет блокироваться до тех пор, пока другая горутина не отправит значение в канал. Таким образом, мы можем отправить значение в канал, чтобы уведомить другую горутину, которая ждет получения значения из того же канала.

В следующем примере канал `done` используется в качестве сигнального канала для уведомлений.

```go
package main

import (
	"crypto/rand"
	"fmt"
	"os"
	"sort"
)

func main() {
	values := make([]byte, 32 * 1024 * 1024)
	if _, err := rand.Read(values); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	done := make(chan struct{}) // может быть буферизованным или нет

	// Горутина сортировки
	go func() {
		sort.Slice(values, func(i, j int) bool {
			return values[i] < values[j]
		})
		// Уведомление о завершении сортировки.
		done <- struct{}{}
	}()

	// делать что-то еще ...

	<- done // ожидание здесь уведомления
	fmt.Println(values[0], values[len(values)-1])
}
```

### 1-к-1 уведомление путем получения значения из канала

Если очередь буфера значений канала заполнена (очередь буфера небуферизованного канала всегда заполнена), операция отправки в канал будет блокироваться до тех пор, пока другая горутина не получит значение из канала. Таким образом, мы можем получить значение из канала, чтобы уведомить другую горутину, которая ждет отправки значения в тот же канал. Обычно канал должен быть небуферизованным.

Этот способ уведомления используется гораздо реже, чем способ, представленный в последнем примере.

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	done := make(chan struct{})
	// Емкость сигнального канала также может
	// быть равна одному. Если это так, то значение
	// должно быть отправлено в канал перед
	// созданием следующей горутины.

	go func() {
		fmt.Print("Hello")
		// Имитация нагрузки.
		time.Sleep(time.Second * 2)

		// Получить значение из канала done,
		// чтобы разблокировать вторую отправку
		// в главной горутине.
		<- done
	}()

	// Блокируется здесь, ожидает уведомления.
	done <- struct{}{}
	fmt.Println(" world!")
}
```

На самом деле, нет принципиальных различий между получением или отправкой значений для уведомлений. Оба способа можно свести к тому, что более быстрые уведомляются более медленными.

### N-к-1 и 1-к-N уведомления

Немного расширив два вышеуказанных случая использования, легко реализовать N-к-1 и 1-к-N уведомления.

```go
package main

import "log"
import "time"

type T = struct{}

func worker(id int, ready <-chan T, done chan<- T) {
	<-ready // блокируется здесь и ждет уведомления
	log.Print("Worker#", id, " starts.")
	// Имитация нагрузки.
	time.Sleep(time.Second * time.Duration(id+1))
	log.Print("Worker#", id, " job done.")
	// Уведомить главную горутину (N-к-1),
	done <- T{}
}

func main() {
	log.SetFlags(0)

	ready, done := make(chan T), make(chan T)
	go worker(0, ready, done)
	go worker(1, ready, done)
	go worker(2, ready, done)

	// Симулировать фазу инициализации.
	time.Sleep(time.Second * 3 / 2)
	// 1-к-N уведомления.
	ready <- T{}; ready <- T{}; ready <- T{}
	// Получение N-к-1 уведомлений.
	<-done; <-done; <-done
}
```

На самом деле, способы реализации 1-к-N и N-к-1 уведомлений, представленные в этом подразделе, не используются часто на практике. На практике мы часто используем `sync.WaitGroup` для N-к-1 уведомлений, а для 1-к-N уведомлений используем закрытие каналов. Пожалуйста, прочитайте следующий подраздел для подробностей.

### Широковещательное (1-к-N) уведомление путем закрытия канала

Способ реализации 1-к-N уведомлений, показанный в последнем подразделе, редко используется на практике, так как есть лучший способ. Используя возможность того, что из закрытого канала можно получить бесконечное количество значений, мы можем закрыть канал для широковещательных уведомлений.

По примеру из последнего подраздела, мы можем заменить три операции отправки в канал `ready <- struct{}{}` в последнем примере одной операцией закрытия канала `close(ready)` для выполнения 1-к-N уведомлений.

```go
...
	close(ready) // широковещательное уведомление
...
```

Конечно, мы также можем закрыть канал для выполнения 1-к-1 уведомления. На самом деле, это наиболее часто используемый способ уведомления в Go.

Возможность получения бесконечного количества значений из закрытого канала будет использоваться во многих других случаях использования, представленных ниже. На самом деле, эта возможность широко используется в стандартных пакетах. Например, пакет `context` использует эту возможность для подтверждения отмен.

### Таймер: запланированное уведомление

Легко использовать каналы для реализации одноразовых таймеров.

Реализация пользовательского одноразового таймера:

```go
package main

import (
	"fmt"
	"time"
)

func AfterDuration(d time.Duration) <- chan struct{} {
	c := make(chan struct{}, 1)
	go func() {
		time.Sleep(d)
		c <- struct{}{}
	}()
	return c
}

func main() {
	fmt.Println("Hi!")
	<- AfterDuration(time.Second)
	fmt.Println("Hello!")
	<- AfterDuration(time.Second)
	fmt.Println("Bye!")
}
```

На самом деле, функция `After` в стандартном пакете `time` предоставляет ту же функциональность с гораздо более эффективной реализацией. Мы должны использовать эту функцию вместо этого, чтобы код выглядел чище.

Обратите внимание, `<-time.After(aDuration)` заставит текущую горутину войти в состояние блокировки, а вызов функции `time.Sleep(aDuration)` — нет.

Использование `<-time.After(aDuration)` часто применяется в механизме таймаута, который будет представлен ниже.

## Использование каналов как мьютексов

Один из вышеуказанных примеров упомянул, что каналы с емкостью один могут использоваться как одноразовый бинарный семафор. На самом деле, такие каналы также могут использоваться как многоразовые бинарные семафоры, то есть мьютексы, хотя такие мьютексы не так эффективны, как мьютексы, предоставляемые в стандартном пакете `sync`.

Есть два способа использования каналов с емкостью один как мьютексов.

1. Блокировка через отправку, разблокировка через получение.
2. Блокировка через получение, разблокировка через отправку.

Ниже приведен пример блокировки через отправку.

```go
package main

import "fmt"

func main() {
	// Емкость должна быть равна одному.
	mutex := make(chan struct{}, 1)

	counter := 0
	increase := func() {
		mutex <- struct{}{} // блокировка
		counter++
		<-mutex // разблокировка
	}

	increase1000 := func(done chan<- struct{}) {
		for i := 0; i < 1000; i++ {
			increase()
		}
		done <- struct{}{}
	}

	done := make(chan struct{})
	go increase1000(done)
	go increase1000(done)
	<-done; <-done
	fmt.Println(counter) // 2000
}
```

Ниже приведен пример блокировки через получение. Он показывает только измененную часть на основе примера блокировки через отправку выше.

```go
...
func main() {
	mutex := make(chan struct{}, 1)
	mutex <- struct{}{} // эта строка нужна.

	counter := 0
	increase := func() {
		<-mutex // блокировка
		counter++
		mutex <- struct{}{} // разблокировка
	}
...
```

## Использование каналов как счетных семафоров

Буферизованные каналы могут использоваться как счетные семафоры. Счетные семафоры можно рассматривать как блокировки с несколькими владельцами. Если емкость канала равна N, то его можно рассматривать как блокировку, которая может иметь максимум N владельцев в любой момент времени. Бинарные семафоры (мьютексы) — это особые счетные семафоры, каждый из которых может иметь максимум одного владельца в любой момент времени.

Счетные семафоры часто используются для ограничения максимального количества конкурентных запросов.

Как и при использовании каналов как мьютексов, есть также два способа получить одну единицу владения семафором канала.

1. Получить владение через отправку, освободить через получение.
2. Получить владение через получение, освободить через отправку.

Пример получения владения через получение значений из канала.

```go
package main

import (
	"log"
	"time"
	"math/rand"
)

type Seat int
type Bar chan Seat

func (bar Bar) ServeCustomer(c int) {
	log.Print("customer#", c, " enters the bar")
	seat := <- bar // нужен стул, чтобы пить
	log.Print("++ customer#", c, " drinks at seat#", seat)
	time.Sleep(time.Second * time.Duration(2 + rand.Intn(6)))
	log.Print("-- customer#", c, " frees seat#", seat)
	bar <- seat // освободить стул и покинуть бар
}

func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20

	// в баре 10 стульев.
	bar24x7 := make(Bar, 10)
	// Разместить стулья в баре.
	for seatId := 0; seatId < cap(bar24x7); seatId++ {
		// Ни одна из отправок не заблокируется.
		bar24x7 <- Seat(seatId)
	}

	for customerId := 0; ; customerId++ {
		time.Sleep(time.Second)
		go bar24x7.ServeCustomer(customerId)
	}

	// сон != блокировка
	for {time.Sleep(time.Second)}
}
```

В вышеуказанном примере только клиенты, каждый из которых получил стул, могут пить. Таким образом, в любой момент времени будет максимум десять клиентов, которые пьют.

Последний цикл `for` в функции `main` предназначен для предотвращения выхода программы. Есть лучший способ сделать это, который будет представлен ниже.

В вышеуказанном примере, хотя в любой момент времени будет максимум десять клиентов, которые пьют, в баре одновременно может обслуживаться более десяти клиентов. Некоторые клиенты ждут свободных стульев. Хотя каждая горутина клиента потребляет гораздо меньше ресурсов, чем системный поток, общие ресурсы, потребляемые большим количеством горутин, не пренебрежимо малы. Поэтому лучше всего создавать горутину клиента только если есть доступный стул.

```go
... // тот же код, что и в примере выше

func (bar Bar) ServeCustomerAtSeat(c int, seat Seat) {
	log.Print("++ customer#", c, " drinks at seat#", seat)
	time.Sleep(time.Second * time.Duration(2 + rand.Intn(6)))
	log.Print("-- customer#", c, " frees seat#", seat)
	bar <- seat // освободить стул и покинуть бар
}

func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20

	bar24x7 := make(Bar, 10)
	for seatId := 0; seatId < cap(bar24x7); seatId++ {
		bar24x7 <- Seat(seatId)
	}

	for customerId := 0; ; customerId++ {
		time.Sleep(time.Second)
		// Нужен стул для обслуживания следующего клиента.
		seat := <- bar24x7
		go bar24x7.ServeCustomerAtSeat(customerId, seat)
	}
	for {time.Sleep(time.Second)}
}
```

В вышеуказанной оптимизированной версии будет максимум около десяти живых горутин клиентов, сосуществующих одновременно (но в течение жизни программы все еще будет создаваться много горутин клиентов).

В более эффективной реализации, показанной ниже, в течение жизни программы будет создано максимум десять горутин обслуживания клиентов.

```go
... // тот же код, что и в примере выше

func (bar Bar) ServeCustomerAtSeat(consumers chan int) {
	for c := range consumers {
		seatId := <- bar
		log.Print("++ customer#", c, " drinks at seat#", seatId)
		time.Sleep(time.Second * time.Duration(2 + rand.Intn(6)))
		log.Print("-- customer#", c, " frees seat#", seatId)
		bar <- seatId // освободить стул и покинуть бар
	}
}

func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20

	bar24x7 := make(Bar, 10)
	for seatId := 0; seatId < cap(bar24x7); seatId++ {
		bar24x7 <- Seat(seatId)
	}

	consumers := make(chan int)
	for i := 0; i < cap(bar24x7); i++ {
		go bar24x7.ServeCustomerAtSeat(consumers)
	}
	
	for customerId := 0; ; customerId++ {
		time.Sleep(time.Second)
		consumers <- customerId
	}
}
```

Отступление: конечно, если нам не важен идентификатор стула (что часто бывает на практике), то семафор `bar24x7` вообще не нужен:

```go
... // тот же код, что и в примере выше

func ServeCustomer(consumers chan int) {
	for c := range consumers {
		log.Print("++ customer#", c, " drinks at the bar")
		time.Sleep(time.Second * time.Duration(2 + rand.Intn(6)))
		log.Print("-- customer#", c, " leaves the bar")
	}
}

func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20

	const BarSeatCount = 10
	consumers := make(chan int)
	for i := 0; i < BarSeatCount; i++ {
		go ServeCustomer(consumers)
	}
	
	for customerId := 0; ; customerId++ {
		time.Sleep(time.Second)
		consumers <- customerId
	}
}
```

Способ получения владения семафором через отправку сравнительно проще. Шаг размещения стульев не нужен.

```go
package main

import (
	"log"
	"time"
	"math/rand"
)

type Customer struct{id int}
type Bar chan Customer

func (bar Bar) ServeCustomer(c Customer) {
	log.Print("++ customer#", c.id, " starts drinking")
	time.Sleep(time.Second * time.Duration(3 + rand.Intn(16)))
	log.Print("-- customer#", c.id, " leaves the bar")
	<- bar // покинуть бар и освободить место
}

func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20

	// Бар может обслуживать максимум 10 клиентов
	// одновременно.
	bar24x7 := make(Bar, 10)
	for customerId := 0; ; customerId++ {
		time.Sleep(time.Second * 2)
		customer := Customer{customerId}
		// Ждать, чтобы войти в бар.
		bar24x7 <- customer
		go bar24x7.ServeCustomer(customer)
	}
	for {time.Sleep(time.Second)}
}
```

## Диалог (Ping-Pong)

Две горутины могут общаться через канал. Ниже приведен пример, который будет печатать ряд чисел Фибоначчи.

```go
package main

import "fmt"
import "time"
import "os"

type Ball uint64

func Play(playerName string, table chan Ball) {
	var lastValue Ball = 1
	for {
		ball := <- table // получить мяч
		fmt.Println(playerName, ball)
		ball += lastValue
		if ball < lastValue { // переполнение
			os.Exit(0)
		}
		lastValue = ball
		table <- ball // отбить мяч обратно
		time.Sleep(time.Second)
	}
}

func main() {
	table := make(chan Ball)
	go func() {
		table <- 1 // бросить мяч на стол
	}()
	go Play("A:", table)
	Play("B:", table)
}
```

## Канал, инкапсулированный в канале

Иногда мы можем использовать тип канала в качестве типа элемента другого типа канала. В следующем примере `chan chan<- int` — это тип канала, тип элемента которого является типом канала только для записи `chan<- int`.

```go
package main

import "fmt"

var counter = func (n int) chan<- chan<- int {
	requests := make(chan chan<- int)
	go func() {
		for request := range requests {
			if request == nil {
				n++ // увеличить
			} else {
				request <- n // взять значение
			}
		}
	}()

	// Неявно преобразуется в chan<- (chan<- int)
	return requests
}(0)

func main() {
	increase1000 := func(done chan<- struct{}) {
		for i := 0; i < 1000; i++ {
			counter <- nil
		}
		done <- struct{}{}
	}

	done := make(chan struct{})
	go increase1000(done)
	go increase1000(done)
	<-done; <-done

	request := make(chan int, 1)
	counter <- request
	fmt.Println(<-request) // 2000
}
```

Хотя здесь реализация инкапсуляции может быть не самым эффективным способом для указанного выше примера, этот случай использования может быть полезен для некоторых других сценариев.

## Проверка длин и емкостей каналов

Мы можем использовать встроенные функции `len` и `cap` для проверки длины и емкости канала. Однако мы редко делаем это на практике. Причина, по которой мы редко используем функцию `len` для проверки длины канала, заключается в том, что длина канала может измениться после возврата вызова функции `len`. Причина, по которой мы редко используем функцию `cap` для проверки емкости канала, заключается в том, что емкость канала часто известна или не важна.

Однако есть некоторые сценарии, когда нам нужно использовать эти две функции. Например, иногда мы хотим получить все значения, буферизованные в незакрытом канале `c`, в который больше никто не будет отправлять значения, тогда мы можем использовать следующий код для получения оставшихся значений.

```go
// Предполагаем, что текущая горутина — единственная
// горутина, которая пытается получить значения из
// канала c в данный момент.
for len(c) > 0 {
	value := <-c
	// использовать value ...
}
```

Мы также можем использовать механизм try-receive, представленный ниже, для выполнения той же задачи. Эффективность двух способов почти одинакова. Преимущество механизма try-receive заключается в том, что текущая горутина не должна быть единственной принимающей горутиной.

Иногда горутина может захотеть записать некоторые значения в буферизованный канал `c`, пока он не заполнится, не входя в состояние блокировки в конце, и горутина является единственным отправителем канала, тогда мы можем использовать следующий код для выполнения этой задачи.

```go
for len(c) < cap(c) {
	c <- aValue
}
```

Конечно, мы также можем использовать механизм try-send, представленный ниже, для выполнения той же задачи.

## Блокировка текущей горутины навсегда

Механизм `select` — это уникальная особенность Go. Он приносит множество паттернов и трюков для конкурентного программирования. О правилах выполнения кода механизма `select` пожалуйста, прочитайте статью [каналы в Go](channel-ru.md).

Мы можем использовать пустой блок `select` `select{}` для блокировки текущей горутины навсегда. Это самый простой случай использования механизма `select`. На самом деле, некоторые использования `for {time.Sleep(time.Second)}` в некоторых вышеуказанных примерах могут быть заменены на `select{}`.

Обычно `select{}` используется для предотвращения выхода главной горутины, так как если главная горутина выходит, вся программа также выходит.

Пример:

```go
package main

import "runtime"

func DoSomething() {
	for {
		// делать что-то ...

		runtime.Gosched() // избежать жадности
	}
}

func main() {
	go DoSomething()
	go DoSomething()
	select{}
}
```

Кстати, есть некоторые другие способы заставить горутину оставаться в состоянии блокировки навсегда. Но способ `select{}` — самый простой.

## Try-Send и Try-Receive

Блок `select` с одной веткой `default` и только одной веткой `case` называется операцией try-send или try-receive канала, в зависимости от того, является ли операция с каналом, следующая за ключевым словом `case`, операцией отправки или получения канала.

Если операция, следующая за ключевым словом `case`, является операцией отправки, то блок `select` называется операцией try-send. Если операция отправки заблокируется, то будет выполнена ветка `default` (не удалось отправить), иначе отправка успешна и будет выполнена единственная ветка `case`.

Если операция, следующая за ключевым словом `case`, является операцией получения, то блок `select` называется операцией try-receive. Если операция получения заблокируется, то будет выполнена ветка `default` (не удалось получить), иначе получение успешно и будет выполнена единственная ветка `case`.

Операции try-send и try-receive никогда не блокируются.

Стандартный компилятор Go делает специальные оптимизации для блоков `select` try-send и try-receive, их эффективность выполнения намного выше, чем у блоков `select` с несколькими ветками `case`.

Ниже приведен пример, который показывает, как работают try-send и try-receive.

```go
package main

import "fmt"

func main() {
	type Book struct{id int}
	bookshelf := make(chan Book, 3)

	for i := 0; i < cap(bookshelf) * 2; i++ {
		select {
		case bookshelf <- Book{id: i}:
			fmt.Println("succeeded to put book", i)
		default:
			fmt.Println("failed to put book")
		}
	}

	for i := 0; i < cap(bookshelf) * 2; i++ {
		select {
		case book := <-bookshelf:
			fmt.Println("succeeded to get book", book.id)
		default:
			fmt.Println("failed to get book")
		}
	}
}
```

Вывод вышеуказанной программы:

```
succeed to put book 0
succeed to put book 1
succeed to put book 2
failed to put book
failed to put book
failed to put book
succeed to get book 0
succeed to get book 1
succeed to get book 2
failed to get book
failed to get book
failed to get book
```

Следующие подразделы покажут больше случаев использования try-send и try-receive.

### Проверка, закрыт ли канал, без блокировки текущей горутины

Предполагая, что гарантировано, что значения никогда не были (и не будут) отправлены в канал, мы можем использовать следующий код для (конкурентной и безопасной) проверки, закрыт ли канал уже или нет, без блокировки текущей горутины, где T — тип элемента соответствующего типа канала.

```go
func IsClosed(c chan T) bool {
	select {
	case <-c:
		return true
	default:
	}
	return false
}
```

Способ проверки, закрыт ли канал, широко используется в конкурентном программировании Go для проверки, пришло ли уведомление. Уведомление будет отправлено путем закрытия канала в другой горутине.

### Ограничение пика/всплеска

Мы можем реализовать ограничение пика, комбинируя использование каналов как счетных семафоров и try-send/try-receive. Ограничение пика (или ограничение всплеска) часто используется для ограничения количества конкурентных запросов без блокировки любых запросов.

Ниже приведена модифицированная версия последнего примера в разделе использования каналов как счетных семафоров.

```go
...
	// Может обслуживать максимум 10 клиентов одновременно
	bar24x7 := make(Bar, 10)
	for customerId := 0; ; customerId++ {
		time.Sleep(time.Second)
		customer := Consumer{customerId}
		select {
		case bar24x7 <- customer: // попытаться войти в бар
			go bar24x7.ServeConsumer(customer)
		default:
			log.Print("customer#", customerId, " goes elsewhere")
		}
	}
...
```

### Другой способ реализации случая использования "первый ответ выигрывает"

Как упоминалось выше, мы можем использовать механизм `select` (try-send) с буферизованным каналом, емкость которого равна одному (по крайней мере), для реализации случая использования "первый ответ выигрывает". Например,

```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func source(c chan<- int32) {
	ra, rb := rand.Int31(), rand.Intn(3)+1
	// Сон 1с, 2с или 3с.
	time.Sleep(time.Duration(rb) * time.Second)
	select {
	case c <- ra:
	default:
	}
}

func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20

	// Емкость должна быть не менее 1.
	c := make(chan int32, 1)
	for i := 0; i < 5; i++ {
		go source(c)
	}
	rnd := <-c // используется только первый ответ
	fmt.Println(rnd)
}
```

Обратите внимание, емкость канала, используемого в вышеуказанном примере, должна быть не менее одного, чтобы первая отправка не была пропущена, если получатель/сторона запроса не готов вовремя.

### Третий способ реализации случая использования "первый ответ выигрывает"

Для случая использования "первый ответ выигрывает", если количество источников небольшое, например, два или три, мы можем использовать блок кода `select` для получения ответов источников одновременно. Например,

```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func source() <-chan int32 {
	// c должен быть буферизованным каналом.
	c := make(chan int32, 1)
	go func() {
		ra, rb := rand.Int31(), rand.Intn(3)+1
		time.Sleep(time.Duration(rb) * time.Second)
		c <- ra
	}()
	return c
}

func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20

	var rnd int32
	// Блокируется здесь, пока один из источников не ответит.
	select{
	case rnd = <-source():
	case rnd = <-source():
	case rnd = <-source():
	}
	fmt.Println(rnd)
}
```

Примечание: если канал, используемый в вышеуказанном примере, является небуферизованным каналом, то после выполнения блока кода `select` будут висеть навсегда две горутины. Это случай утечки памяти.

Два способа, представленные в текущем и последнем подразделах, также могут использоваться для выполнения N-к-1 уведомлений.

### Таймаут

В некоторых сценариях запрос-ответ, по разным причинам, запрос может потребовать длительного времени для ответа, иногда даже никогда не ответит. Для таких случаев мы должны вернуть сообщение об ошибке клиентской стороне, используя решение с таймаутом. Такое решение с таймаутом может быть реализовано с помощью механизма `select`.

Следующий код показывает, как сделать запрос с таймаутом.

```go
func requestWithTimeout(timeout time.Duration) (int, error) {
	c := make(chan int)
	// Может потребоваться длительное время для получения ответа.
	go doRequest(c)

	select {
	case data := <-c:
		return data, nil
	case <-time.After(timeout):
		return 0, errors.New("timeout")
	}
}
```

### Тикер

Мы можем использовать механизм try-send для реализации тикера.

```go
package main

import "fmt"
import "time"

func Tick(d time.Duration) <-chan struct{} {
	// Емкость c лучше установить равной одному.
	c := make(chan struct{}, 1)
	go func() {
		for {
			time.Sleep(d)
			select {
			case c <- struct{}{}:
			default:
			}
		}
	}()
	return c
}

func main() {
	t := time.Now()
	for range Tick(time.Second) {
		fmt.Println(time.Since(t))
	}
}
```

На самом деле, в стандартном пакете `time` есть функция `Tick`, которая предоставляет ту же функциональность с гораздо более эффективной реализацией. Мы должны использовать эту функцию вместо этого, чтобы код выглядел чище и работал эффективно.

### Ограничение скорости

Один из вышеуказанных разделов показал, как использовать try-send для ограничения пика. Мы также можем использовать try-send для ограничения скорости (с помощью тикера). На практике ограничение скорости часто используется для избежания превышения квоты и истощения ресурсов.

Ниже показан такой пример, заимствованный у jh oh из официального вики Go. В этом примере количество обработанных запросов в любую одну минуту не превысит 200.

```go
package main

import "fmt"
import "time"

type Request interface{}
func handle(r Request) {fmt.Println(r.(int))}

const RateLimitPeriod = time.Minute
const RateLimit = 200 // максимум 200 запросов за одну минуту

func handleRequests(requests <-chan Request) {
	quotas := make(chan time.Time, RateLimit)

	go func() {
		tick := time.NewTicker(RateLimitPeriod / RateLimit)
		defer tick.Stop()
		for t := range tick.C {
			select {
			case quotas <- t:
			default:
			}
		}
	}()

	for r := range requests {
		<-quotas
		go handle(r)
	}
}

func main() {
	requests := make(chan Request)
	go handleRequests(requests)
	// time.Sleep(time.Minute)
	for i := 0; ; i++ {requests <- i}
}
```

На практике мы часто используем ограничение скорости и ограничение пика/всплеска вместе.

## Переключатели

Из статьи [каналы в Go](channel-ru.md) мы узнали, что отправка значения в или получение значения из `nil` канала являются блокирующими операциями. Используя этот факт, мы можем изменить задействованные каналы в операциях `case` блока кода `select`, чтобы повлиять на выбор ветки в блоке кода `select`.

Ниже приведен еще один пример ping-pong, который реализован с использованием механизма `select`. В этом примере одна из двух переменных канала, задействованных в блоке `select`, равна `nil`. Ветка `case`, соответствующая `nil` каналу, определенно не будет выбрана. Мы можем думать, что такие ветки `case` находятся в выключенном состоянии. В конце каждого шага цикла состояния включения/выключения двух веток `case` переключаются.

```go
package main

import "fmt"
import "time"
import "os"

type Ball uint8
func Play(playerName string, table chan Ball, serve bool) {
	var receive, send chan Ball
	if serve {
		receive, send = nil, table
	} else {
		receive, send = table, nil
	}
	var lastValue Ball = 1
	for {
		select {
		case send <- lastValue:
		case value := <- receive:
			fmt.Println(playerName, value)
			value += lastValue
			if value < lastValue { // переполнение
				os.Exit(0)
			}
			lastValue = value
		}
		// Переключить включение/выключение.
		receive, send = send, receive
		time.Sleep(time.Second)
	}
}

func main() {
	table := make(chan Ball)
	go Play("A:", table, false)
	Play("B:", table, true)
}
```

Ниже приведен еще один (не конкурентный) пример, который намного проще и также демонстрирует эффект переключения. Этот пример будет печатать 1212... при выполнении. Он не имеет большой полезности на практике. Он показан здесь только в целях обучения.

```go
package main

import "fmt"
import "time"

func main() {
	for c := make(chan struct{}, 1); true; {
		select {
		case c <- struct{}{}:
			fmt.Print("1")
		case <-c:
			fmt.Print("2")
		}
		time.Sleep(time.Second)
	}
}
```

## Управление весами вероятности выполнения кода

Мы можем дублировать ветку `case` в блоке кода `select`, чтобы увеличить вес вероятности выполнения соответствующего кода.

Пример:

```go
package main

import "fmt"

func main() {
	foo, bar := make(chan struct{}), make(chan struct{})
	close(foo); close(bar) // для демонстрации
	x, y := 0.0, 0.0
	f := func(){x++}
	g := func(){y++}
	for i := 0; i < 100000; i++ {
		select {
		case <-foo: f()
		case <-foo: f()
		case <-bar: g()
		}
	}
	fmt.Println(x/y) // около 2
}
```

Вероятность вызова функции `f` примерно вдвое больше вероятности вызова функции `g`.

## Выбор из динамического количества случаев

Хотя количество веток в блоке `select` фиксировано, мы можем использовать функциональность, предоставляемую в стандартном пакете `reflect`, для построения блока `select` во время выполнения. Динамически созданный блок `select` может иметь произвольное количество веток `case`. Но обратите внимание, способ с отражением менее эффективен, чем фиксированный способ.

Стандартный пакет `reflect` также предоставляет функции `TrySend` и `TryRecv` для реализации блоков `select` с одним случаем плюс `default`.

## Манипуляции с потоками данных

Этот раздел представит некоторые случаи использования манипуляций с потоками данных с использованием каналов.

Обычно приложение потока данных состоит из многих модулей. Разные модули выполняют разную работу. Каждый модуль может иметь одного или нескольких воркеров (горутин), которые конкурентно выполняют одну и ту же работу, указанную для этого модуля. Вот список некоторых примеров работы модулей на практике:

* генерация/сбор/загрузка данных.
* обслуживание/сохранение данных.
* вычисление/анализ данных.
* валидация/фильтрация данных.
* агрегация/разделение данных
* композиция/декомпозиция данных.
* дублирование/размножение данных.

Воркер в модуле может получать данные от нескольких других модулей в качестве входных данных и отправлять данные для обслуживания других модулей в качестве выходных данных. Другими словами, модуль может быть как потребителем данных, так и производителем данных. Модуль, который только отправляет данные некоторым другим модулям, но никогда не получает данные от других модулей, называется модулем только-производитель. Модуль, который только получает данные от некоторых других модулей, но никогда не отправляет данные другим модулям, называется модулем только-потребитель.

Многие модули вместе образуют систему потока данных.

Ниже будут показаны некоторые реализации воркеров модулей потока данных. Эти реализации предназначены для объяснения, поэтому они очень просты и могут быть неэффективными.

### Генерация/сбор/загрузка данных

Есть всевозможные модули только-производители. Воркер модуля только-производителя может производить поток данных

* загружая файл, читая базу данных или сканируя веб.
* собирая всевозможные метрики из программной системы или всевозможного оборудования.
* генерируя случайные числа.
* и т.д.

Здесь мы используем генератор случайных чисел в качестве примера. Функция генератора возвращает один результат, но не принимает параметров.

```go
import (
	"crypto/rand"
	"encoding/binary"
)

func RandomGenerator() <-chan uint64 {
	c := make(chan uint64)
	go func() {
		rnds := make([]byte, 8)
		for {
			_, err := rand.Read(rnds)
			if err != nil {
				close(c)
				break
			}
			c <- binary.BigEndian.Uint64(rnds)
		}
	}()
	return c
}
```

На самом деле, генератор случайных чисел — это future/promise с множественными возвратами.

Производитель данных может закрыть выходной канал потока в любой момент, чтобы завершить генерацию данных.

### Агрегация данных

Воркер модуля агрегации данных объединяет несколько потоков данных одного и того же типа данных в один поток. Предполагая, что тип данных — `int64`, то следующая функция объединит произвольное количество потоков данных в один.

```go
func Aggregator(inputs ...<-chan uint64) <-chan uint64 {
	out := make(chan uint64)
	for _, in := range inputs {
		go func(in <-chan uint64) {
			for {
				out <- <-in // <=> out <- (<-in)
			}
		}(in)
	}
	return out
}
```

Лучшая реализация должна учитывать, был ли закрыт входной поток. (Также верно для следующих других реализаций воркеров модулей.)

```go
import "sync"

func Aggregator(inputs ...<-chan uint64) <-chan uint64 {
	output := make(chan uint64)
	var wg sync.WaitGroup
	for _, in := range inputs {
		wg.Add(1)
		go func(in <-chan uint64) {
			defer wg.Done()
			// Если in закрыт, то
			// цикл в конечном итоге закончится.
			for x := range in {
				output <- x
			}
		}(in)
	}
	go func() {
		wg.Wait()
		close(output)
	}()
	return output
}
```

Если количество объединенных потоков данных очень мало (два или три), мы можем использовать блок `select` для объединения этих потоков данных.

```go
// Предполагаем, что количество входных потоков равно двум.
...
	output := make(chan uint64)
	go func() {
		inA, inB := inputs[0], inputs[1]
		for {
			select {
			case v := <- inA: output <- v
			case v := <- inB: output <- v
			}
		}
	}
...
```

### Разделение данных

Воркер модуля разделения данных делает противоположное воркеру модуля агрегации данных. Легко реализовать воркера разделения, но на практике воркеры разделения не очень полезны и редко используются.

```go
func Divisor(input <-chan uint64, outputs ...chan<- uint64) {
	for _, out := range outputs {
		go func(o chan<- uint64) {
			for {
				o <- <-input // <=> o <- (<-input)
			}
		}(out)
	}
}
```

### Композиция данных

Воркер композиции данных объединяет несколько частей данных из разных входных потоков данных в одну часть данных.

Ниже приведен пример воркера композиции, в котором два значения `uint64` из одного потока и одно значение `uint64` из другого потока составляют одно новое значение `uint64`. Конечно, типы элементов потоков каналов обычно различаются на практике.

```go
func Composer(inA, inB <-chan uint64) <-chan uint64 {
	output := make(chan uint64)
	go func() {
		for {
			a1, b, a2 := <-inA, <-inB, <-inA
			output <- a1 ^ b & a2
		}
	}()
	return output
}
```

### Декомпозиция данных

Декомпозиция данных — это обратный процесс композиции данных. Реализация функции воркера декомпозиции принимает один параметр входного потока данных и возвращает несколько результатов потоков данных. Здесь не будут показаны примеры декомпозиции данных.

### Дублирование/размножение данных

Дублирование (размножение) данных можно рассматривать как особые декомпозиции данных. Одна часть данных будет продублирована, и каждая из продублированных данных будет отправлена в разные выходные потоки данных.

Пример:

```go
func Duplicator(in <-chan uint64) (<-chan uint64, <-chan uint64) {
	outA, outB := make(chan uint64), make(chan uint64)
	go func() {
		for x := range in {
			outA <- x
			outB <- x
		}
	}()
	return outA, outB
}
```

### Вычисление/анализ данных

Функциональность модулей вычисления и анализа данных различается, и каждая очень специфична. Обычно функция-воркер таких модулей преобразует каждую часть входных данных в другую часть выходных данных.

В целях простой демонстрации здесь показан пример воркера, который инвертирует каждый бит каждого переданного значения `uint64`.

```go
func Calculator(in <-chan uint64, out chan uint64) <-chan uint64 {
	if out == nil {
		out = make(chan uint64)
	}
	go func() {
		for x := range in {
			out <- ^x
		}
	}()
	return out
}
```

### Валидация/фильтрация данных

Модуль валидации или фильтрации данных отбрасывает некоторые переданные данные в потоке. Например, следующая функция-воркер отбрасывает все не простые числа.

```go
import "math/big"

func Filter0(input <-chan uint64, output chan uint64) <-chan uint64 {
	if output == nil {
		output = make(chan uint64)
	}
	go func() {
		bigInt := big.NewInt(0)
		for x := range input {
			bigInt.SetUint64(x)
			if bigInt.ProbablyPrime(1) {
				output <- x
			}
		}
	}()
	return output
}

func Filter(input <-chan uint64) <-chan uint64 {
	return Filter0(input, nil)
}
```

Обратите внимание, что каждая из двух реализаций используется одним из двух последних примеров, показанных ниже.

### Обслуживание/сохранение данных

Обычно модуль обслуживания или сохранения данных является последним или финальным выходным модулем в системе потока данных. Здесь просто предоставлен простой воркер, который печатает каждую часть данных, полученных из входного потока.

```go
import "fmt"

func Printer(input <-chan uint64) {
	for x := range input {
		fmt.Println(x)
	}
}
```

### Сборка системы потока данных

Теперь давайте используем вышеуказанные функции-воркеры модулей для сборки нескольких систем потоков данных. Сборка системы потока данных — это просто создание некоторых воркеров разных модулей и указание входных потоков для каждого воркера.

Пример системы потока данных 1 (линейный конвейер):

```go
package main

... // функции-воркеры, объявленные выше.

func main() {
	Printer(
		Filter(
			Calculator(
				RandomGenerator(), nil,
			),
		),
	)
}
```

Вышеуказанная система потока данных изображена на следующей диаграмме.

![Линейный конвейер](https://go101.org/article/res/data-flow-linear-pipeline.png)

Пример системы потока данных 2 (направленный ациклический граф конвейер):

```go
package main

... // функции-воркеры, объявленные выше.

func main() {
	filterA := Filter(RandomGenerator())
	filterB := Filter(RandomGenerator())
	filterC := Filter(RandomGenerator())
	filter := Aggregator(filterA, filterB, filterC)
	calculatorA := Calculator(filter, nil)
	calculatorB := Calculator(filter, nil)
	calculator := Aggregator(calculatorA, calculatorB)
	Printer(calculator)
}
```

Вышеуказанная система потока данных изображена на следующей диаграмме.

![Направленный ациклический граф конвейер](https://go101.org/article/res/data-flow-dag-pipeline.png)

Более сложная топология системы потока данных может быть произвольным графом. Например, система потока данных может иметь несколько финальных выходов. Но системы потоков данных с топологией циклического графа редко используются в реальности.

Из двух вышеуказанных примеров мы можем обнаружить, что очень легко и интуитивно строить системы потоков данных с каналами.

Из последнего примера мы можем обнаружить, что с помощью агрегаторов легко реализовать fan-in и fan-out для количества воркеров указанного модуля.

На самом деле, мы можем использовать простой канал для замены роли агрегатора. Например, следующий пример заменяет два агрегатора двумя каналами.

```go
package main

... // функции-воркеры, объявленные выше.

func main() {
	c1 := make(chan uint64, 100)
	Filter0(RandomGenerator(), c1) // filterA
	Filter0(RandomGenerator(), c1) // filterB
	Filter0(RandomGenerator(), c1) // filterC
	c2 := make(chan uint64, 100)
	Calculator(c1, c2) // calculatorA
	Calculator(c1, c2) // calculatorB
	Printer(c2)
}
```

Модифицированная система потока данных изображена на следующей диаграмме.

![Модифицированная система потока данных](https://go101.org/article/res/data-flow-modified-dag-pipeline.png)

Вышеприведенные объяснения систем потоков данных не рассматривают много того, как закрывать потоки данных. Пожалуйста, прочитайте [эту статью](https://go101.org/article/channel-closing.html) для объяснений о том, как корректно закрывать каналы.

---

**Источник:** [Channel Use Cases - Go 101](https://go101.org/article/channel-use-cases.html)
