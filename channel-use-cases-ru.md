# Случаи использования каналов в Go

Перед прочтением этой статьи, пожалуйста, прочитайте статью [каналы в Go](channel-ru.md), которая подробно объясняет типы каналов и их значения. Новичкам в Go может потребоваться прочитать ту статью и текущую несколько раз, чтобы освоить программирование с каналами Go.

Оставшаяся часть этой статьи покажет множество случаев использования каналов. Я надеюсь, что эта статья убедит вас в том, что:

* асинхронное и конкурентное программирование с каналами Go просто и приятно.
* техника синхронизации через каналы имеет более широкий диапазон применений и больше вариаций, чем решения синхронизации, используемые в некоторых других языках, таких как модель акторов и паттерн async/await.

Обратите внимание, что цель этой статьи — показать как можно больше случаев использования каналов. Мы должны понимать, что канал — это не единственная техника синхронизации конкурентности, поддерживаемая в Go, и для некоторых случаев использование каналов может быть не лучшим решением. Пожалуйста, прочитайте [атомарные операции](https://go101.org/article/concurrent-atomic-operation.html) и [другие техники синхронизации](https://go101.org/article/concurrent-synchronization-more.html) для получения дополнительных техник синхронизации конкурентности в Go.

## Использование каналов как Futures/Promises

Futures и promises используются во многих других популярных языках. Они часто ассоциируются с запросами и ответами.

### Возврат каналов только для чтения как результатов

В следующем примере значения двух аргументов вызова функции `sumSquares` запрашиваются конкурентно. Каждая из двух операций приема по каналу будет блокироваться до тех пор, пока операция отправки не выполнится на соответствующем канале. Для возврата окончательного результата требуется около трех секунд вместо шести.

```go
package main

import (
	"time"
	"math/rand"
	"fmt"
)

func longTimeRequest() <-chan int32 {
	r := make(chan int32)

	go func() {
		// Имитация нагрузки.
		time.Sleep(time.Second * 3)
		r <- rand.Int31n(100)
	}()

	return r
}

func sumSquares(a, b int32) int32 {
	return a*a + b*b
}

func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20

	a, b := longTimeRequest(), longTimeRequest()
	fmt.Println(sumSquares(<-a, <-b))
}
```

### Передача каналов только для записи в качестве аргументов

Так же, как в последнем примере, в следующем примере значения двух аргументов вызова функции `sumSquares` запрашиваются конкурентно. В отличие от последнего примера, функция `longTimeRequest` принимает канал только для записи в качестве параметра вместо возврата результата канала только для чтения.

```go
package main

import (
	"time"
	"math/rand"
	"fmt"
)

func longTimeRequest(r chan<- int32)  {
	// Имитация нагрузки.
	time.Sleep(time.Second * 3)
	r <- rand.Int31n(100)
}

func sumSquares(a, b int32) int32 {
	return a*a + b*b
}

func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20

	ra, rb := make(chan int32), make(chan int32)
	go longTimeRequest(ra)
	go longTimeRequest(rb)

	fmt.Println(sumSquares(<-ra, <-rb))
}
```

На самом деле, для указанного выше примера нам не нужны два канала для передачи результатов. Использование одного канала тоже подойдет.

```go
...

	// Канал может быть буферизованным или нет.
	results := make(chan int32, 2)
	go longTimeRequest(results)
	go longTimeRequest(results)

	fmt.Println(sumSquares(<-results, <-results))
}
```

Это своего рода агрегация данных, которая будет специально представлена ниже.

### Первый ответ выигрывает

Это улучшение варианта использования только одного канала из последнего примера.

Иногда часть данных может быть получена из нескольких источников, чтобы избежать высокой задержки. Из-за множества факторов длительность ответов этих источников может сильно различаться. Даже для указанного источника его длительность ответов также не постоянна. Чтобы сделать длительность ответа как можно короче, мы можем отправить запрос каждому источнику в отдельной горутине. Будет использован только первый ответ, остальные более медленные будут отброшены.

Обратите внимание, если есть N источников, емкость канала связи должна быть не менее N-1, чтобы избежать блокировки навсегда горутин, соответствующих отброшенным ответам.

```go
package main

import (
	"fmt"
	"time"
	"math/rand"
)

func source(c chan<- int32) {
	ra, rb := rand.Int31(), rand.Intn(3) + 1
	// Сон 1с/2с/3с.
	time.Sleep(time.Duration(rb) * time.Second)
	c <- ra
}

func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20

	startTime := time.Now()
	// c должен быть буферизованным каналом.
	c := make(chan int32, 5)
	for i := 0; i < cap(c); i++ {
		go source(c)
	}
	// Будет использован только первый ответ.
	rnd := <- c
	fmt.Println(time.Since(startTime))
	fmt.Println(rnd)
}
```

Есть другие способы реализовать случай использования "первый ответ выигрывает", используя механизм select и буферизованный канал с емкостью один. Другие способы будут представлены ниже.

### Дополнительные варианты запрос-ответ

Каналы параметров и результатов могут быть буферизованными, чтобы сторонам ответа не нужно было ждать, пока стороны запроса заберут переданные значения.

Иногда запрос не гарантирует получение валидного значения в ответе. По разным причинам вместо этого может быть возвращена ошибка. Для таких случаев мы можем использовать тип структуры, такой как `struct{v T; err error}` или тип пустого интерфейса в качестве типа элемента канала.

Иногда по некоторым причинам ответ может потребовать гораздо больше времени, чем ожидалось, чтобы прийти, или никогда не придет. Мы можем использовать механизм таймаута, представленный ниже, для обработки таких обстоятельств.

Иногда последовательность значений может быть возвращена со стороны ответа, это своего рода механизм потока данных, упомянутый позже ниже.

## Использование каналов для уведомлений

Уведомления можно рассматривать как особые запросы/ответы, в которых переданные значения не важны. Обычно мы используем тип пустой структуры `struct{}` в качестве типов элементов каналов уведомлений, поскольку размер типа `struct{}` равен нулю, следовательно, значения `struct{}` не потребляют память.

### 1-к-1 уведомление путем отправки значения в канал

Если нет значений для получения из канала, то следующая операция приема по каналу будет блокироваться до тех пор, пока другая горутина не отправит значение в канал. Таким образом, мы можем отправить значение в канал, чтобы уведомить другую горутину, которая ждет получения значения из того же канала.

В следующем примере канал `done` используется в качестве сигнального канала для уведомлений.

```go
package main

import (
	"crypto/rand"
	"fmt"
	"os"
	"sort"
)

func main() {
	values := make([]byte, 32 * 1024 * 1024)
	if _, err := rand.Read(values); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	done := make(chan struct{}) // может быть буферизованным или нет

	// Горутина сортировки
	go func() {
		sort.Slice(values, func(i, j int) bool {
			return values[i] < values[j]
		})
		// Уведомление о завершении сортировки.
		done <- struct{}{}
	}()

	// делать что-то еще ...

	<- done // ожидание здесь уведомления
	fmt.Println(values[0], values[len(values)-1])
}
```

### 1-к-1 уведомление путем получения значения из канала

Если очередь буфера значений канала заполнена (очередь буфера небуферизованного канала всегда заполнена), операция отправки в канал будет блокироваться до тех пор, пока другая горутина не получит значение из канала. Таким образом, мы можем получить значение из канала, чтобы уведомить другую горутину, которая ждет отправки значения в тот же канал. Обычно канал должен быть небуферизованным.

Этот способ уведомления используется гораздо реже, чем способ, представленный в последнем примере.

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	done := make(chan struct{})
		// Емкость сигнального канала также может
		// быть равна одному. Если это так, то значение
		// должно быть отправлено в канал перед
		// созданием следующей горутины.

	go func() {
		fmt.Print("Hello")
		// Имитация нагрузки.
		time.Sleep(time.Second * 2)

		// Получить значение из канала,
		// чтобы уведомить другую горутину.
		<- done
	}()

	// Выполнить операцию отправки, чтобы уведомить
	// горутину выше.
	done <- struct{}{}
	fmt.Println(" world!")
}
```

### 1-ко-многим и многие-к-1 уведомления

Если значение будет отправлено (или получено) из канала, несколько горутин могут получать (или отправлять) значения из (или в) тот же канал, чтобы все они были уведомлены. Таким образом, мы можем использовать каналы для 1-ко-многим и многие-к-1 уведомлений.

В следующем примере используется 1-ко-многим уведомление.

```go
package main

import (
	"time"
	"fmt"
)

func main() {
	done := make(chan struct{})

	// Сигнальная горутина
	go func() {
		time.Sleep(time.Second)
		fmt.Println("done")
		// Уведомить все горутины
		close(done)
	}()

	// Рабочие горутины
	for i := 0; i < 4; i++ {
		go func(id int) {
			<-done // ждать уведомления
			fmt.Println("worker", id)
		}(i)
	}

	time.Sleep(time.Second * 2)
}
```

### Многие-к-1 уведомление

Следующий пример демонстрирует случай многие-к-1 уведомления:

```go
package main

import (
	"fmt"
	"time"
	"math/rand"
)

func worker(id int, ready <-chan struct{}, done chan<- struct{}) {
	<-ready // ждать сигнала готовности
	fmt.Println("worker", id, "запущен")
	time.Sleep(time.Second * time.Duration(rand.Intn(5)))
	fmt.Println("worker", id, "завершен")
	done <- struct{}{} // уведомить главную горутину
}

func main() {
	rand.Seed(time.Now().UnixNano())

	ready, done := make(chan struct{}), make(chan struct{})
	go worker(0, ready, done)
	go worker(1, ready, done)
	go worker(2, ready, done)

	// Симулировать операцию инициализации
	time.Sleep(time.Second * 3 / 2)
	// Всем рабочим горутинам подать сигнал одновременно
	close(ready)
	// Ждать завершения всех рабочих горутин
	<-done
	<-done
	<-done
}
```

### Таймауты и отмены

Механизм select-case может использоваться для реализации таймаутов. Обратите внимание, что второй case делает отмену без блокировки, если операция не может быть выполнена немедленно.

```go
func doWithTimeout(timeout time.Duration) (int, error) {
	select {
	case result := <-fastRequest():
		return result, nil
	case <-time.After(timeout):
		return 0, errors.New("timeout")
	}
}
```

Мы можем использовать каналы для реализации отмены операций. В следующем примере `cancel` канал используется для отмены операции:

```go
func doWithCancel(cancel <-chan struct{}) (int, error) {
	select {
	case result := <-request():
		return result, nil
	case <-cancel:
		return 0, errors.New("отменено")
	}
}
```

### Таймеры и тикеры

Хотя пакет `time` предоставляет `time.Timer` и `time.Ticker`, каналы также могут использоваться для реализации таймеров и тикеров:

```go
// Таймер
func timer(d time.Duration) <-chan time.Time {
	c := make(chan time.Time, 1)
	go func() {
		time.Sleep(d)
		c <- time.Now()
	}()
	return c
}

// Тикер
func ticker(d time.Duration) <-chan time.Time {
	c := make(chan time.Time, 1)
	go func() {
		for {
			time.Sleep(d)
			select {
			case c <- time.Now():
			default:
			}
		}
	}()
	return c
}
```

## Использование каналов для передачи данных

Каналы могут использоваться для передачи данных между горутинами. Это основное использование каналов.

### Точка-точка передачи данных

В следующем примере показана простая передача данных точка-точка:

```go
func main() {
	c := make(chan int)

	go func() {
		c <- 42 // отправка данных
	}()

	data := <-c // получение данных
	fmt.Println(data)
}
```

### Потоковая передача данных

Каналы отлично подходят для потоковой передачи данных. В следующем примере показано, как использовать каналы для передачи потока чисел:

```go
func numberStream() <-chan int {
	c := make(chan int)
	go func() {
		defer close(c)
		for i := 0; i < 10; i++ {
			c <- i
		}
	}()
	return c
}

func main() {
	for num := range numberStream() {
		fmt.Println(num)
	}
}
```

## Использование каналов для ограничения конкурентности

Каналы могут использоваться для ограничения количества одновременно выполняющихся операций:

### Ограничение конкурентности с буферизованными каналами

```go
func main() {
	const limit = 3
	semaphore := make(chan struct{}, limit)

	for i := 0; i < 10; i++ {
		semaphore <- struct{}{} // захват
		go func(id int) {
			defer func() { <-semaphore }() // освобождение
			// выполнить работу
			fmt.Println("работа", id)
		}(i)
	}

	// дождаться завершения всех работ
	for i := 0; i < limit; i++ {
		semaphore <- struct{}{}
	}
}
```

## Использование каналов для координации

Каналы могут использоваться для координации работы между несколькими горутинами:

### Барьер синхронизации

```go
func main() {
	const numWorkers = 3
	barrier := make(chan struct{})

	for i := 0; i < numWorkers; i++ {
		go func(id int) {
			// выполнить работу
			fmt.Println("worker", id, "работает")
			barrier <- struct{}{} // сигнал завершения
		}(i)
	}

	// дождаться всех рабочих
	for i := 0; i < numWorkers; i++ {
		<-barrier
	}
	fmt.Println("все завершено")
}
```

## Использование каналов для пулов воркеров

Каналы отлично подходят для создания пулов воркеров:

### Простой пул воркеров

```go
func worker(id int, jobs <-chan int, results chan<- int) {
	for job := range jobs {
		// выполнить работу
		result := job * 2
		results <- result
	}
}

func main() {
	const numWorkers = 3
	const numJobs = 9

	jobs := make(chan int, numJobs)
	results := make(chan int, numJobs)

	// запустить воркеров
	for i := 0; i < numWorkers; i++ {
		go worker(i, jobs, results)
	}

	// отправить задания
	for j := 1; j <= numJobs; j++ {
		jobs <- j
	}
	close(jobs)

	// получить результаты
	for r := 1; r <= numJobs; r++ {
		fmt.Println(<-results)
	}
}
```

## Системы потоков данных

С помощью каналов очень легко создавать системы потоков данных. Обычно в системе потоков данных есть несколько модулей (воркеров), и каждый модуль выполняет определенную работу.

### Генерация данных

Генератор данных создает поток данных. Вот простой пример:

```go
func RandomGenerator() <-chan uint64 {
	c := make(chan uint64)
	go func() {
		r := rand.New(rand.NewSource(time.Now().UnixNano()))
		for {
			c <- r.Uint64()
		}
	}()
	return c
}
```

### Агрегация данных

Модуль агрегации объединяет несколько потоков данных в один поток. В следующем примере все значения, принятые из нескольких входных каналов, отправляются в один выходной канал:

```go
func Aggregator(inputs ...<-chan uint64) <-chan uint64 {
	output := make(chan uint64)
	var wg sync.WaitGroup
	wg.Add(len(inputs))

	for _, input := range inputs {
		go func(in <-chan uint64) {
			defer wg.Done()
			for x := range in {
				output <- x
			}
		}(input)
	}

	go func() {
		wg.Wait()
		close(output)
	}()

	return output
}
```

### Дублирование данных

Модуль дублирования отправляет каждую часть входных данных в несколько выходных потоков. Каждая часть входных данных будет продублирована, и каждый из дублированных данных будет отправлен в разные выходные потоки данных.

Пример:

```go
func Duplicator(in <-chan uint64) (<-chan uint64, <-chan uint64) {
	outA, outB := make(chan uint64), make(chan uint64)
	go func() {
		for x := range in {
			outA <- x
			outB <- x
		}
	}()
	return outA, outB
}
```

### Вычисление/анализ данных

Функциональность модулей вычисления и анализа данных различается, и каждая очень специфична. Обычно функция-воркер такого модуля преобразует каждую часть входных данных в другую часть выходных данных.

В целях простой демонстрации здесь показан пример воркера, который инвертирует каждый бит каждого переданного значения `uint64`.

```go
func Calculator(in <-chan uint64, out chan uint64) (<-chan uint64) {
	if out == nil {
		out = make(chan uint64)
	}
	go func() {
		for x := range in {
			out <- ^x
		}
	}()
	return out
}
```

### Валидация/фильтрация данных

Модуль валидации или фильтрации данных отбрасывает некоторые переданные данные в потоке. Например, следующая функция-воркер отбрасывает все не простые числа.

```go
import "math/big"

func Filter0(input <-chan uint64, output chan uint64) <-chan uint64 {
	if output == nil {
		output = make(chan uint64)
	}
	go func() {
		bigInt := big.NewInt(0)
		for x := range input {
			bigInt.SetUint64(x)
			if bigInt.ProbablyPrime(1) {
				output <- x
			}
		}
	}()
	return output
}

func Filter(input <-chan uint64) <-chan uint64 {
	return Filter0(input, nil)
}
```

Обратите внимание, что каждая из двух реализаций используется одним из двух последних примеров, показанных ниже.

### Обслуживание/сохранение данных

Обычно модуль обслуживания или сохранения данных является последним или финальным выходным модулем в системе потоков данных. Здесь просто предоставлен простой воркер, который печатает каждую часть данных, полученных из входного потока.

```go
import "fmt"

func Printer(input <-chan uint64) {
	for x := range input {
		fmt.Println(x)
	}
}
```

### Сборка системы потоков данных

Теперь давайте используем вышеуказанные функции-воркеры модулей для сборки нескольких систем потоков данных. Сборка системы потоков данных — это просто создание некоторых воркеров разных модулей и указание входных потоков для каждого воркера.

Пример системы потоков данных 1 (линейный конвейер):

```go
package main

... // функции-воркеры, объявленные выше.

func main() {
	Printer(
		Filter(
			Calculator(
				RandomGenerator(), nil,
			),
		),
	)
}
```

Пример системы потоков данных 2 (направленный ациклический граф конвейер):

```go
package main

... // функции-воркеры, объявленные выше.

func main() {
	filterA := Filter(RandomGenerator())
	filterB := Filter(RandomGenerator())
	filterC := Filter(RandomGenerator())
	filter := Aggregator(filterA, filterB, filterC)
	calculatorA := Calculator(filter, nil)
	calculatorB := Calculator(filter, nil)
	calculator := Aggregator(calculatorA, calculatorB)
	Printer(calculator)
}
```

Более сложная топология системы потоков данных может быть произвольным графом. Например, система потоков данных может иметь несколько финальных выходов. Но системы потоков данных с топологией циклического графа редко используются в реальности.

Из двух вышеприведенных примеров мы можем обнаружить, что очень легко и интуитивно строить системы потоков данных с каналами.

Из последнего примера мы можем обнаружить, что с помощью агрегаторов легко реализовать fan-in и fan-out для количества воркеров указанного модуля.

На самом деле, мы можем использовать простой канал для замены роли агрегатора. Например, следующий пример заменяет два агрегатора двумя каналами.

```go
package main

... // функции-воркеры, объявленные выше.

func main() {
	c1 := make(chan uint64, 100)
	Filter0(RandomGenerator(), c1) // filterA
	Filter0(RandomGenerator(), c1) // filterB
	Filter0(RandomGenerator(), c1) // filterC
	c2 := make(chan uint64, 100)
	Calculator(c1, c2) // calculatorA
	Calculator(c1, c2) // calculatorB
	Printer(c2)
}
```

Вышеприведенные объяснения систем потоков данных не рассматривают много того, как закрывать потоки данных. Пожалуйста, прочитайте [эту статью](https://go101.org/article/channel-closing.html) для объяснений о том, как корректно закрывать каналы.

---

## 🎯 Задания для закрепления

### 🧩 Уровень 1 — Базовое взаимодействие через канал

**Задача:**

Напиши программу, в которой:
- Одна горутина отправляет в канал числа от 1 до 5.
- Другая горутина получает эти числа и печатает их.
- После завершения отправки канал закрывается, а принимающая горутина использует `for range` для получения всех значений.

**Что закрепляется:**

- отправка и получение через канал;
- закрытие канала;
- использование `for range` для чтения до закрытия.

---

### ⚙️ Уровень 2 — Несколько горутин и буфер

**Задача:**

Создай буферизованный канал ёмкостью 3.

- Запусти 3 горутины-отправителя, каждая из которых пишет в канал своё имя (например, "A", "B", "C").
- Запусти горутину-приёмник, которая читает из канала и выводит полученные значения.
- Закрой канал после того, как все отправители завершили работу.

**Что закрепляется:**

- буферизованные каналы;
- конкурентная отправка;
- синхронизация (можно использовать `sync.WaitGroup`).

---

### ⚡ Уровень 3 — Использование select

**Задача:**

Напиши программу, где две горутины каждую секунду отправляют разные сообщения в два канала:

- первая — "ping",
- вторая — "pong".

Главная горутина использует `select` для получения сообщений из любого из каналов и печатает их.

Если в течение 5 секунд нет ни одного сообщения — программа завершает работу.

**Что закрепляется:**

- `select-case` для множественных каналов;
- обработка конкурентных событий;
- работа с `time.After` для тайм-аутов.

---

### 🚀 Уровень 4 — Сложная координация

**Задача:**

Реализуй "производитель–потребитель":

- Горутина-производитель генерирует числа от 1 до 10 и отправляет их в канал.
- Две горутины-потребителя читают эти числа через `select`, обрабатывают (например, возводят в квадрат) и выводят результат.
- Когда все данные прочитаны — программа завершается.

**Что закрепляется:**

- балансировка нагрузки через канал;
- конкурентная обработка;
- завершение всех горутин при закрытии канала.

---

### 🧠 Уровень 5 — Задача на понимание GC и блокировок

**Задача:**

Создай горутину, которая ждёт чтения из небуферизованного канала, но никто никогда не пишет в него.

Посмотри, как программа "зависает" (горутина блокируется навсегда).

Затем добавь `select {}` — и убедись, что главный поток тоже блокируется навсегда.

**Что закрепляется:**

- поведение заблокированных горутин;
- понимание, когда канал и горутина могут быть собраны GC;
- практика отладки зависших горутин (`go tool pprof`, `runtime.NumGoroutine()`).

---

**Источник:** [Channel Use Cases - Go 101](https://go101.org/article/channel-use-cases.html)

