# Каналы в Go

Канал — это важная встроенная функция в Go. Это одна из функций, которая делает Go уникальным. Вместе с другой уникальной функцией, горутиной, канал делает конкурентное программирование удобным, приятным и снижает сложность конкурентного программирования.

Канал в основном действует как техника синхронизации конкурентности. В этой статье будут перечислены все концепции, синтаксис и правила, связанные с каналами. Для лучшего понимания каналов также кратко описываются внутренняя структура каналов и некоторые детали реализации стандартным компилятором/рантаймом Go.

Информация в этой статье может быть немного сложной для новичков в Go. Некоторые части этой статьи может потребоваться прочитать несколько раз, чтобы полностью понять.

## Введение в каналы

Один из советов (предложенный Робом Пайком) для конкурентного программирования: не давайте вычислениям общаться через разделяемую память, пусть они разделяют память через общение (через каналы). (Мы можем рассматривать каждое вычисление как горутину в программировании на Go.)

Общение через разделяемую память и разделение памяти через общение — это два стиля программирования в конкурентном программировании. Когда горутины общаются через разделяемую память, мы используем традиционные техники синхронизации конкурентности, такие как мьютексы, для защиты разделяемой памяти, чтобы предотвратить гонки данных. Мы можем использовать каналы для реализации разделения памяти через общение.

Go предоставляет уникальную технику синхронизации конкурентности — канал. Каналы позволяют горутинам разделять память через общение. Мы можем рассматривать канал как внутреннюю очередь FIFO (первый пришел, первый ушел) внутри программы. Некоторые горутины отправляют значения в очередь (канал), а другие горутины получают значения из очереди.

Вместе с передачей значений (через каналы) владение некоторыми значениями также может быть передано между горутинами. Когда горутина отправляет значение в канал, мы можем рассматривать это как то, что горутина освобождает владение некоторыми значениями (к которым можно получить доступ через отправленное значение). Когда горутина получает значение из канала, мы можем рассматривать это как то, что горутина получает владение некоторыми значениями (к которым можно получить доступ через полученное значение).

Конечно, также может не быть никакого переноса владения вместе с коммуникацией через каналы.

Значения (чье владение переносится) часто ссылаются (но не обязательно ссылаются) на переданное значение. Обратите внимание, здесь, когда мы говорим о владении, мы имеем в виду владение с логической точки зрения. Каналы Go могут помочь программистам легко писать код без гонок данных, но каналы Go не могут предотвратить написание плохого конкурентного кода на уровне синтаксиса.

Хотя Go также поддерживает традиционные техники синхронизации конкурентности, только канал является первоклассным гражданином в Go. Канал — это один из типов в Go, поэтому мы можем использовать каналы без импорта каких-либо пакетов. С другой стороны, эти традиционные техники синхронизации конкурентности предоставляются в стандартных пакетах `sync` и `sync/atomic`.

Честно говоря, каждая техника синхронизации конкурентности имеет свои лучшие сценарии использования. Но канал имеет более широкий диапазон применения и больше разнообразия в использовании. Одна проблема каналов заключается в том, что опыт программирования с каналами настолько приятен и интересен, что программисты часто даже предпочитают использовать каналы для сценариев, для которых каналы не являются лучшим выбором.

## Типы и значения каналов

Как массив, слайс и карта, каждый тип канала имеет тип элемента. Канал может передавать только значения типа элемента канала.

Типы каналов могут быть двунаправленными или однонаправленными. Предположим, `T` — произвольный тип:

1. `chan T` обозначает двунаправленный тип канала. Компиляторы позволяют как получать значения из, так и отправлять значения в двунаправленные каналы.
2. `chan<- T` обозначает тип канала только для отправки. Компиляторы не позволяют получать значения из каналов только для отправки.
3. `<-chan T` обозначает тип канала только для приема. Компиляторы не позволяют отправлять значения в каналы только для приема.

`T` называется типом элемента этих типов каналов.

Значения двунаправленного типа канала `chan T` могут быть неявно преобразованы как в тип только для отправки `chan<- T`, так и в тип только для приема `<-chan T`, но не наоборот (даже явно). Значения типа только для отправки `chan<- T` не могут быть преобразованы в тип только для приема `<-chan T`, и наоборот. Обратите внимание, что знаки `<-` в литералах типов каналов являются модификаторами.

Каждое значение канала имеет емкость, что будет объяснено в разделе после следующего. Значение канала с нулевой емкостью называется небуферизованным каналом, а значение канала с ненулевой емкостью называется буферизованным каналом.

Нулевые значения типов каналов представлены предобъявленным идентификатором `nil`. Ненулевое значение канала должно быть создано с помощью встроенной функции `make`. Например, `make(chan int, 10)` создаст канал, тип элемента которого — `int`. Второй аргумент вызова функции `make` указывает емкость новосозданного канала. Второй параметр является опциональным, и его значение по умолчанию — ноль.

## Сравнение значений каналов

Все типы каналов являются сравниваемыми типами.

Из статьи [части значений](https://go101.org/article/value-part.html) мы знаем, что ненулевые значения каналов являются многокомпонентными значениями. Если одно значение канала присваивается другому, два канала разделяют одну и ту же базовую часть (части). Другими словами, эти два канала представляют один и тот же внутренний объект канала. Результат их сравнения — `true`.

## Операции с каналами

Есть пять операций, специфичных для каналов. Предположим, канал — `ch`, их синтаксис и вызовы функций этих операций перечислены здесь.

1. Закрыть канал, используя следующий вызов функции  
```go  
close(ch)  
```  
где `close` — встроенная функция. Аргумент вызова функции `close` должен быть значением канала, и канал `ch` не должен быть каналом только для приема.

2. Отправить значение, `v`, в канал, используя следующий синтаксис  
```go  
ch <- v  
```  
где `v` должно быть значением, которое может быть присвоено типу элемента канала `ch`, и канал `ch` не должен быть каналом только для приема. Обратите внимание, что здесь `<-` — оператор отправки в канал.

3. Получить значение из канала, используя следующий синтаксис  
```go  
<-ch  
```  
Операция приема из канала всегда возвращает по крайней мере один результат, который является значением типа элемента канала, и канал `ch` не должен быть каналом только для отправки. Обратите внимание, что здесь `<-` — оператор приема из канала. Да, его представление такое же, как у оператора отправки в канал.  
Для большинства сценариев операция приема из канала рассматривается как выражение с одним значением. Однако, когда операция с каналом используется как единственное исходное значение в присваивании, она может вернуть второе опциональное нетипизированное булево значение и стать выражением с несколькими значениями. Нетипизированное булево значение указывает, было ли первое значение отправлено до закрытия канала. (Ниже мы узнаем, что из закрытого канала можно получить неограниченное количество значений.)  
Две операции приема из канала, которые используются как исходные значения в присваиваниях:  
```go  
v = <-ch  
v, sentBeforeClosed = <-ch  
```

4. Запросить емкость буфера значений канала, используя следующий вызов функции  
```go  
cap(ch)  
```  
где `cap` — встроенная функция, которая уже была представлена в контейнерах в Go. Возвращаемый результат вызова функции `cap` — значение типа `int`.

5. Запросить текущее количество значений в буфере значений (или длину) канала, используя следующий вызов функции  
```go  
len(ch)  
```  
где `len` — встроенная функция, которая также уже была представлена ранее. Возвращаемое значение вызова функции `len` — значение типа `int`. Результирующая длина — это количество элементов, которые уже были успешно отправлены в запрошенный канал, но еще не были получены (извлечены).

Большинство базовых операций в Go не синхронизированы. Другими словами, они не являются безопасными для конкурентности. Эти операции включают присваивание значений, передачу аргументов и манипуляции с элементами контейнеров и т.д. Однако все только что представленные операции с каналами уже синхронизированы, поэтому дополнительная синхронизация не требуется для безопасного выполнения этих операций.

Как и большинство других операций в Go, присваивание значений каналов не синхронизировано. Аналогично, присваивание полученного значения другому значению также не синхронизировано, хотя любая операция приема из канала синхронизирована.

Если запрошенный канал — nil-канал, обе встроенные функции `cap` и `len` возвращают ноль. Эти две операции запроса настолько просты, что они не будут дополнительно объясняться позже. На самом деле, эти две операции редко используются для каналов.

## Получение значений из закрытых каналов

После закрытия канала можно продолжать получать значения из него, пока все значения из буфера канала не будут извлечены. После того, как все значения будут извлечены, все последующие операции приема из канала немедленно вернут нулевое значение типа элемента канала без блокировки.

Как уже упоминалось выше, операция приема из канала может возвращать два значения. Второе значение — это булево значение, которое указывает, было ли первое значение отправлено до закрытия канала. Если второе значение — `false`, это означает, что канал был закрыт и буфер канала пуст, поэтому первое значение должно быть нулевым значением типа элемента канала.

**Важно:** отправка значения в закрытый канал вызывает панику. Попытка закрыть уже закрытый канал также вызывает панику.

## Отправка и получение операций блокируются навсегда

Операция отправки на nil-канал или операция получения из nil-канала будет блокироваться навсегда. Это поведение полезно в некоторых особых сценариях.

## Отправка и получение операций блокируются временно

Когда операция отправки выполняется на небуферизованном канале (не nil), она будет блокироваться до тех пор, пока другая горутина не получит значение из этого канала. И наоборот, когда операция получения выполняется на небуферизованном канале (не nil), она будет блокироваться до тех пор, пока другая горутина не отправит значение в этот канал.

Для буферизованного канала (не nil):
- Операция отправки блокируется только тогда, когда буфер канала полон. Если в буфере есть свободное место, операция отправки не будет блокироваться.
- Операция получения блокируется только тогда, когда буфер канала пуст. Если в буфере есть значения, операция получения не будет блокироваться.

## Каналы используются в выражениях if и for

Записи `<-ch` могут использоваться как простые операторы в операторе `if` или как операнды в операторе `for-range`.

Пример:

```go
package main

import "fmt"

func main() {
	c := make(chan int, 2)
	c <- 1
	c <- 2
	close(c)

	if v, ok := <-c; ok {
		fmt.Println(v) // 1
	}
	if v, ok := <-c; ok {
		fmt.Println(v) // 2
	}
	if v, ok := <-c; ok {
		fmt.Println(v) // не выполнится
	} else {
		fmt.Println("канал закрыт")
	}

	for v := range c {
		fmt.Println(v) // не выполнится, канал уже пуст
	}
}
```

## Приоритеты операторов каналов

Оператор приема из канала `<-` имеет самый низкий приоритет операторов среди всех операторов в Go.

Приоритет оператора отправки в канал `<-` выше, чем приоритет оператора приема из канала.

Примеры:

```go
<-ch + 5    // означает: (<-ch) + 5
<- ch       // означает: <-ch
```

## Получение всех значений, отправленных в канал

Как уже упоминалось выше, после закрытия канала мы все еще можем получать значения из него, пока все значения не будут извлечены. Но как мы узнаем, когда все значения были извлечены? Фактически, вторая возвращаемая булева опция операции приема из канала может помочь нам в этом.

```go
for {
	value, ok := <-ch
	if !ok {
		// канал закрыт и все значения извлечены
		break
	}
	// использовать value
}
```

Или еще проще:

```go
for value := range ch {
	// использовать value
}
```

Оператор `for-range` на канале будет автоматически прерываться, когда канал будет закрыт и все значения будут извлечены.

## Полировка каналов

В Go нет явной "полировки" каналов, как в некоторых других языках программирования. Однако закрытие канала может рассматриваться как способ завершения работы с каналом.

## Внутренняя структура каналов

Канал внутренне представлен структурой типа `runtime.hchan`. Пакет runtime Go поддерживает множество внутренних структур для разных типов значений. Все внутренние типы структур для контейнеров и строк определены в файле `runtime/map.go`, `runtime/slice.go`, `runtime/string.go` и `runtime/chan.go`.

Каждая структура `runtime.hchan` содержит следующие поля:

- `buf` — указатель на буфер (который является циклической очередью)
- `sendx` и `recvx` — индексы для отправки и приема в буфере
- `lock` — мьютекс для защиты конкурентного доступа
- `sendq` и `recvq` — очереди ожидающих горутин (отправителей и получателей)
- `closed` — флаг, указывающий, закрыт ли канал
- `elemtype` и `elemsize` — тип и размер элемента канала
- `dataqsiz` — емкость буфера

## Проблемы с производительностью каналов

Хотя каналы удобны для конкурентного программирования, они могут стать узким местом производительности в некоторых случаях. Основные причины:

1. **Блокировки:** операции с каналами могут блокировать горутины, что может привести к снижению пропускной способности.
2. **Накладные расходы:** каналы имеют внутренние структуры данных и мьютексы, которые добавляют накладные расходы по сравнению с прямым доступом к памяти.
3. **Горутины в очередях:** когда много горутин блокируется на канале, это может создать большие очереди и задержки.

Для высокопроизводительных сценариев иногда лучше использовать другие техники синхронизации, такие как атомарные операции или `sync` пакет.

## Каналы в select операторах

Механизм `select-case` — это еще одна важная функция в Go для работы с каналами. Оператор `select` позволяет горутине ожидать нескольких операций с каналами одновременно.

### Синтаксис select

```go
select {
case v := <-ch1:
	// получено значение из ch1
case v := <-ch2:
	// получено значение из ch2
case ch3 <- value:
	// отправлено значение в ch3
default:
	// все каналы заблокированы, выполнить это
}
```

### Поведение select

1. Если несколько `case` готовы, один выбирается случайным образом.
2. Если ни один `case` не готов и есть `default`, выполняется `default`.
3. Если ни один `case` не готов и нет `default`, операция блокируется до тех пор, пока один из `case` не станет готов.

### Примеры использования select

**Таймауты:**

```go
select {
case result := <-ch:
	// получить результат
case <-time.After(5 * time.Second):
	// таймаут
}
```

**Отмена операций:**

```go
select {
case result := <-ch:
	// получить результат
case <-ctx.Done():
	// операция отменена
}
```

**Неблокирующие операции:**

```go
select {
case v := <-ch:
	// получили значение
default:
	// канал не готов, продолжаем без блокировки
}
```

## Реализация механизма select

Механизм select в Go — это важная и уникальная функция. Здесь перечислены шаги реализации механизма select официальным рантаймом Go.

Есть несколько шагов для выполнения блока `select-case`:

1. Вычислить все задействованные выражения каналов и выражения значений, которые потенциально будут отправлены в операциях `case`, сверху вниз и слева направо. Целевые значения для операций приема (как исходные значения) в присваиваниях не нужно вычислять в это время.
2. Рандомизировать порядок ветвей для опроса на шаге 5. Ветвь `default` всегда помещается в последнюю позицию в результирующем порядке. Каналы могут дублироваться в операциях `case`.
3. Отсортировать все задействованные каналы в операциях `case`, чтобы избежать взаимоблокировки (с другими горутинами) на следующем шаге. Нет дублирующихся каналов среди первых `N` каналов отсортированного результата, где `N` — это количество задействованных каналов в операциях `case`. Ниже порядок блокировки каналов — это концепция для первых `N` каналов в отсортированном результате.
4. Заблокировать (то есть получить блокировки) всех задействованных каналов по порядку блокировки каналов, полученному на последнем шаге.
5. Опросить каждую ветвь в блоке select по рандомизированному порядку, полученному на шаге 2:  
   1. если это ветвь `case` и соответствующая операция с каналом — это операция отправки значения в закрытый канал, разблокировать все каналы в обратном порядке блокировки каналов и заставить текущую горутину вызвать панику. Перейти к шагу 12.  
   2. если это ветвь `case` и соответствующая операция с каналом неблокирующая, выполнить операцию с каналом и разблокировать все каналы в обратном порядке блокировки каналов, затем выполнить соответствующее тело ветви `case`. Операция с каналом может разбудить другую горутину в заблокированном состоянии. Перейти к шагу 12.  
   3. если это ветвь `default`, то разблокировать все каналы в обратном порядке блокировки каналов и выполнить тело ветви `default`. Перейти к шагу 12.  
(До этого момента ветвь `default` отсутствует, и все операции `case` являются блокирующими операциями.)
6. Поместить (поставить в очередь) текущую горутину (вместе с информацией о соответствующей ветви `case`) в очередь горутин отправки или приема задействованного канала в каждой операции `case`. Текущая горутина может быть помещена в очереди канала несколько раз, поскольку задействованные каналы в нескольких случаях могут быть одним и тем же.
7. Заставить текущую горутину войти в заблокированное состояние и разблокировать все каналы в обратном порядке блокировки каналов.
8. Ждать в заблокированном состоянии, пока другие операции с каналами разбудят текущую горутину, ...
9. Текущая горутина разбужена другой операцией с каналом в другой горутине. Другая операция может быть операцией закрытия канала или операцией отправки/приема канала. Если это операция отправки/приема канала, должна быть соответствующая операция приема/отправки канала `case` (в текущем объясняемом блоке `select-case`), которая сотрудничает с ней (путем передачи значения). В сотрудничестве текущая горутина будет удалена из очереди горутин приема/отправки канала.
10. Заблокировать все задействованные каналы по порядку блокировки каналов.
11. Удалить текущую горутину из очереди горутин приема или очереди горутин отправки задействованного канала в каждой операции `case`,  
   1. если текущая горутина разбужена операцией закрытия канала, перейти к шагу 5.  
   2. если текущая горутина разбужена операцией отправки/приема канала, соответствующая ветвь `case` сотрудничающей операции приема/отправки уже найдена в процессе удаления из очереди, поэтому просто разблокировать все каналы в обратном порядке блокировки каналов и выполнить соответствующую ветвь `case`.
12. Готово.

Из реализации мы знаем, что:

1. горутина может находиться в очередях горутин отправки и очередях горутин приема нескольких каналов одновременно. Она даже может находиться в очереди горутин отправки и очереди горутин приема одного и того же канала одновременно.
2. когда горутина, в настоящее время заблокированная на блоке кода `select-case`, позже возобновляется, она будет удалена из всех очередей горутин отправки и всех очередей горутин приема всех каналов, задействованных в операциях с каналами, следующих за ключевыми словами `case` в блоке кода `select-case`.

## Дополнительно

Мы можем найти больше случаев использования каналов в [этой статье](channel-use-cases-ru.md).

Хотя каналы могут помочь нам легко писать правильный конкурентный код, как и другие техники синхронизации данных, каналы не предотвратят написание неправильного конкурентного кода.

Канал может быть не всегда лучшим решением для всех случаев использования для синхронизации данных. Пожалуйста, прочитайте [эту статью](https://go101.org/article/concurrent-synchronization-overview.html) и [эту статью](https://go101.org/article/concurrent-synchronization-more.html) для получения дополнительных техник синхронизации в Go.

---

**Источник:** [Channels in Go - Go 101](https://go101.org/article/channel.html)

